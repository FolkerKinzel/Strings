<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FolkerKinzel.Strings</name>
    </assembly>
    <members>
        <member name="T:System.Buffers.SpanAction`2">
            <summary>
            Polyfill für das ab .NET Standard 2.0 verfügbare Delegat System.Buffers.SpanAction&lt;T,TArg&gt;.
            </summary>
            <typeparam name="T">Der Typ der Objekte in der Spanne.</typeparam>
            <typeparam name="TArg">Der Typ des Objekts, das den Zustand darstellt.
            Dieser Typparameter ist kontravariant. Das bedeutet, dass Sie entweder den angegebenen Typ oder 
            einen weniger abgeleiteten Typ verwenden können. </typeparam>
            <param name="span">Eine Spanne von Objekten des Typs <typeparamref name="T"/>.</param>
            <param name="arg">Ein Zustandsobjekt des Typs <typeparamref name="TArg"/>.</param>
        </member>
        <member name="T:FolkerKinzel.Strings.CharExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.Char"/>-Struktur.
            </summary>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsAsciiLowerCaseLetter(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen ein ASCII-Kleinbuchstabe ist.
            </summary>
            <param name="c">Das zu überprüfende Unicode-Zeichen.</param>
            <returns><c>true</c> wenn <paramref name="c"/> ein ASCII-Kleinbuchstabe ist,
            andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsAsciiUpperCaseLetter(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen ein ASCII-Großbuchstabe ist.
            </summary>
            <param name="c">Das zu überprüfende Unicode-Zeichen.</param>
            <returns><c>true</c> wenn <paramref name="c"/> ein ASCII-Großbuchstabe ist,
            andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsAsciiLetter(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen ein ASCII-Buchstabe ist.
            </summary>
            <param name="c">Das zu überprüfende Unicode-Zeichen.</param>
            <returns><c>true</c> wenn <paramref name="c"/> ein ASCII-Buchstabe ist,
            andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.ParseHexDigit(System.Char)">
            <summary>
            Ruft den Wert einer Hexadezimalziffer ab.
            </summary>
            <param name="digit">Die zu konvertierende Hexadezimalziffer (0-9, a-f, A-F).</param>
            <returns>Eine Zahl von 0 bis 15, die der angegebenen Hexadezimalziffer entspricht.</returns>
            <remarks>Ruft <see cref="M:System.Uri.FromHex(System.Char)"/> auf.</remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="digit"/> ist keine gültige Hexadezimalziffer (0-9, a-f, A-F).
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.TryParseHexDigit(System.Char,System.Nullable{System.Int32}@)">
            <summary>
            Versucht, ein Zeichen als Hexadezimalziffer zu interpretieren und den Wert, den 
            diese Hexadezimalziffer darstellt, zurückzugeben.
            </summary>
            <param name="digit">Das zu analysierende Zeichen.</param>
            <param name="value">Enthält nach der erfolgreichen Beendigung der Methode den Wert,
            den <paramref name="digit"/> als Hexadezimalziffer
            darstellt, andernfalls <c>null</c>. Der Parameter wird uninitialisiert übergeben.</param>
            <returns><c>true</c>, wenn <paramref name="digit"/> eine Hexadezimalziffer darstellt,
            andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.TryParseDecimalDigit(System.Char,System.Nullable{System.Int32}@)">
            <summary>
            Versucht, ein Zeichen als Dezimalziffer (0-9) zu interpretieren und den Wert, den 
            diese Dezimalziffer darstellt, zurückzugeben.
            </summary>
            <param name="digit">Das zu analysierende Zeichen.</param>
            <param name="value">Enthält nach der erfolgreichen Beendigung der Methode den Wert,
            den <paramref name="digit"/> als Dezimalziffer
            darstellt, andernfalls <c>null</c>. Der Parameter wird uninitialisiert übergeben.</param>
            <returns><c>true</c>, wenn <paramref name="digit"/> eine Dezimalziffer darstellt,
            andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.TryParseBinaryDigit(System.Char,System.Nullable{System.Int32}@)">
            <summary>
            Versucht, ein Zeichen als Binärziffer (0 oder 1) zu interpretieren und den Wert, den 
            diese Dezimalziffer darstellt, zurückzugeben.
            </summary>
            <param name="digit">Das zu analysierende Zeichen.</param>
            <param name="value">Enthält nach der erfolgreichen Beendigung der Methode den Wert,
            den <paramref name="digit"/> als Binärziffer
            darstellt, andernfalls <c>null</c>. Der Parameter wird uninitialisiert übergeben.</param>
            <returns><c>true</c>, wenn <paramref name="digit"/> eine Binärziffer darstellt,
            andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.ParseBinaryDigit(System.Char)">
            <summary>
            Ruft den Wert einer Binärziffer ab.
            </summary>
            <param name="digit">Die zu konvertierende Binärziffer (0 oder 1).</param>
            <returns>Eine Zahl, die der angegebenen Binärziffer entspricht.</returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="digit"/> ist keine gültige Binärziffer (0 oder 1).
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.ParseDecimalDigit(System.Char)">
            <summary>
            Ruft den Wert einer Dezimalziffer ab.
            </summary>
            <param name="digit">Die zu konvertierende Dezimalziffer (0-9).</param>
            <returns>Eine Zahl von 0 bis 9, die der angegebenen Dezimalziffer entspricht.</returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="digit"/> ist keine gültige Dezimalziffer (0-9).
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsAscii(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen zum ASCII-Zeichensatz gehört.
            </summary>
            <param name="c">Das zu überprüfende Unicode-Zeichen.</param>
            <returns><c>true</c> wenn <paramref name="c"/> ein Zeichen des ASCII-Zeichensatzes ist,
            andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsDecimalDigit(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen eine Dezimalziffer (0-9) darstellt.
            </summary>
            <param name="c">Das zu überprüfende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> eine Dezimalziffer
            darstellt, andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsHexDigit(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen eine eine gültige Hexadezimalziffer (0-9, a-f, A-F) ist.
            </summary>
            <param name="character">Das zu überprüfende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="character"/> eine Hexadezimalziffer
            ist, andernfalls <c>false</c>.</returns>
            <remarks>Ruft <see cref="M:System.Uri.IsHexDigit(System.Char)"/> auf.</remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsBinaryDigit(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen eine Binärziffer (0 oder 1) darstellt.
            </summary>
            <param name="c">Das zu überprüfende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> eine Binärziffer
            darstellt, andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsControl(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Steuerzeichen kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Steuerzeichen
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsControl(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsDigit(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Mitglied der Unicode-Kategorie
            "Decimal Digit Number" kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als
            Mitglied der Unicode-Kategorie
            "Decimal Digit Number"
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            <para>
            Ruft die Methode <see cref="M:System.Char.IsDigit(System.Char)"/> auf.
            </para>
            <note type="important">
            Zur Unicode-Kategorie "Decimal Digit Number" gehören sehr viel mehr
            Zeichen als die Ziffern 0-9. Verwenden sie die Methode <see cref="M:FolkerKinzel.Strings.CharExtension.IsDecimalDigit(System.Char)"/>,
            wenn Sie auf die Zeichen 0-9 prüfen möchten.
            </note>
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsHighSurrogate(System.Char)">
            <summary>
            Untersucht, ob <paramref name="c"/> ein hohes Ersatzzeichen ist.
            </summary>
            <param name="c">Die auszuwertende <see cref="T:System.Char"/>-Instanz.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> ein hohes 
            Ersatzzeichen ist, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsHighSurrogate(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsLowSurrogate(System.Char)">
            <summary>
            Untersucht, ob <paramref name="c"/> ein niedriges Ersatzzeichen ist.
            </summary>
            <param name="c">Die auszuwertende <see cref="T:System.Char"/>-Instanz.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> ein niedriges 
            Ersatzzeichen ist, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsLowSurrogate(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsSurrogate(System.Char)">
            <summary>
            Untersucht, ob <paramref name="c"/> über eine Ersatzzeichencodeeinheit verfügt.
            </summary>
            <param name="c">Die auszuwertende <see cref="T:System.Char"/>-Instanz.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> über eine Ersatzzeichencodeeinheit 
            verfügt, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsSurrogate(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsLetter(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Unicode-Buchstabe kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Unicode-Buchstabe
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsLetter(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsLetterOrDigit(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Buchstabe oder Dezimalzahl kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Buchstabe oder Dezimalzahl
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsLetterOrDigit(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsLower(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Kleinbuchstabe kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Kleinbuchstabe
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsLower(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsUpper(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Großbuchstabe kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Großbuchstabe
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsUpper(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsNumber(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Zahl kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Zahl
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsNumber(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsPunctuation(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Satzzeichen kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Satzzeichen 
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsPunctuation(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsSeparator(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Trennzeichen kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Trennzeichen 
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsSeparator(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsSymbol(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Symbolzeichen kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Symbolzeichen 
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsSymbol(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsWhiteSpace(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Leerzeichen kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Leerzeichen 
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.ToLowerInvariant(System.Char)">
            <summary>
            Konvertiert den Wert eines Unicode-Zeichens in dessen Entsprechung 
            in Kleinbuchstaben unter Verwendung der Regeln der invarianten Kultur für Groß- und Kleinschreibung.
            </summary>
            <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
            <returns>Die Entsprechung des <paramref name="c"/>-Parameters in Kleinbuchstaben oder 
            der unveränderte Wert von <paramref name="c"/>, wenn <paramref name="c"/> bereits aus Kleinbuchstaben 
            besteht oder kein alphabetischer Wert ist.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.ToLowerInvariant(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.ToUpperInvariant(System.Char)">
            <summary>
            Konvertiert den Wert eines Unicode-Zeichens in dessen Entsprechung 
            in Großbuchstaben unter Verwendung der Regeln der invarianten Kultur für Groß- und Kleinschreibung.
            </summary>
            <param name="c">Das zu konvertierende Unicode-Zeichen.</param>
            <returns>Die Entsprechung des <paramref name="c"/>-Parameters in Großbuchstaben oder 
            der unveränderte Wert von <paramref name="c"/>, wenn <paramref name="c"/> bereits aus Großbuchstaben 
            besteht oder kein alphabetischer Wert ist.</returns>
            <remarks>
            Ruft <see cref="M:System.Char.ToUpperInvariant(System.Char)"/> auf.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)">
            <summary>
            Untersucht, ob das Unicode-Zeichen als Zeilenwechselzeichen kategorisiert wird.
            </summary>
            <param name="c">Das auszuwertende Unicode-Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="c"/> als Zeilenwechselzeichen
            kategorisiert wird, andernfalls <c>false</c>.</returns>
            <remarks>
            <para>
            Als Zeilenwechselzeichen werden die folgenden Zeichen erkannt:
            </para>
            <list type="bullet">
            <item>CR: Carriage Return (U+000D)</item>
            <item>LF: Line Feed      (U+000A)</item>
            <item>VT: Vertical Tab        (U+000B)</item>
            <item>FF: Form Feed           (U+000C)</item>
            <item>NEL: Next Line          (U+0085)</item>
            <item>LS: Line Separator      (U+2028)</item>
            <item>PS: Paragraph Separator (U+2029)</item>
            </list>
            </remarks>
        </member>
        <member name="T:FolkerKinzel.Strings.DecoderValidationFallback">
            <summary>
            Stellt einen als Fallback bezeichneten Fehlerbehandlungsmechanismus für eine codierte Eingabebytefolge bereit, 
            die nicht in ein Ausgabezeichen konvertiert werden kann. Das Fallback gibt eine benutzerdefinierte Ersatzzeichenfolge (&#x2B1C;)
            anstelle einer decodierten Eingabebytefolge aus und informiert in seiner Eigenschaft <see cref="P:FolkerKinzel.Strings.DecoderValidationFallback.HasError"/> darüber,
            ob ein Fehler aufgetreten ist.
            </summary>
            <remarks>
            Verwenden Sie <see cref="T:FolkerKinzel.Strings.DecoderValidationFallback"/>-Objekte in den Methoden
            <list type="bullet">
            <item><see cref="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)">
            Encoding.GetEncoding(int, EncoderFallback, DecoderFallback)</see></item>
            <item><see cref="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)">
            Encoding.GetEncoding(string, EncoderFallback, DecoderFallback)</see> oder</item>
            <item><see cref="M:FolkerKinzel.Strings.TextEncodingConverter.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback,System.Boolean)">
            TextEncodingConverter.GetEncoding(int, EncoderFallback, DecoderFallback, bool)</see> und</item>
            <item><see cref="M:FolkerKinzel.Strings.TextEncodingConverter.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback,System.Boolean)">
            TextEncodingConverter.GetEncoding(int, EncoderFallback, DecoderFallback, bool)</see>.</item>
            </list>
            <para>
            Das <see cref="T:FolkerKinzel.Strings.DecoderValidationFallback"/>-Objekt wird dabei als <see cref="T:System.Text.DecoderFallback"/>-Objekt übergeben.
            </para>
            <para>
            Die <see cref="T:FolkerKinzel.Strings.DecoderValidationFallback"/>-Klasse verhält sich wie die Klasse 
            <see cref="T:System.Text.DecoderReplacementFallback"/>, mit dem Unterschied, dass sie in ihrer Eigenschaft <see cref="P:FolkerKinzel.Strings.DecoderValidationFallback.HasError"/>
            nach Benutzung darüber informiert, ob ein Fehler aufgetreten ist. Zur Auswertung der Eigenschaft, sollten Sie eine 
            Referenz auf das <see cref="T:FolkerKinzel.Strings.DecoderValidationFallback"/>-Objekt behalten oder den Rückgabewert der Eigenschaft 
            <see cref="P:System.Text.Encoding.DecoderFallback">Encoding.DecoderFallback</see> in den Typ 
            <see cref="T:FolkerKinzel.Strings.DecoderValidationFallback"/> casten.
            </para>
            <para>
            Wenn Sie das <see cref="T:FolkerKinzel.Strings.DecoderValidationFallback"/>-Objekt mehrfach verwenden, können sie die Eigenschaft
            <see cref="P:FolkerKinzel.Strings.DecoderValidationFallback.HasError"/> mit der Methode <see cref="M:FolkerKinzel.Strings.DecoderValidationFallback.Reset"/> zurücksetzen.
            </para>
            </remarks>
        </member>
        <member name="P:FolkerKinzel.Strings.DecoderValidationFallback.HasError">
            <summary>
            Gibt an, ob ein Dekodierungsfehler aufgetreten ist.
            </summary>
            <value><c>true</c>, wenn ein Fehler aufgetreten ist, andernfalls <c>false</c>.</value>
        </member>
        <member name="M:FolkerKinzel.Strings.DecoderValidationFallback.Reset">
            <summary>
            Setzt die Eigenschaft <see cref="P:FolkerKinzel.Strings.DecoderValidationFallback.HasError"/> auf ihren Ausgangswert
            <c>false</c> zurück.
            </summary>
        </member>
        <member name="P:FolkerKinzel.Strings.DecoderValidationFallback.MaxCharCount">
            <inheritdoc/>
        </member>
        <member name="M:FolkerKinzel.Strings.DecoderValidationFallback.CreateFallbackBuffer">
            <inheritdoc/>
        </member>
        <member name="T:FolkerKinzel.Strings.DecoderValidationFallback.ValidatorFallbackBuffer">
            ///////////////////////////////////////////////////////////////
        </member>
        <member name="T:FolkerKinzel.Strings.FileInfoExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.IO.FileInfo"/>-Klasse.
            </summary>
        </member>
        <member name="M:FolkerKinzel.Strings.FileInfoExtension.IsUtf8(System.IO.FileInfo,System.Int32)">
            <summary>
            Testet, ob der Abschnitt der durch <paramref name="fileInfo"/> angegebenen Datei, der sich vom Dateianfang über mindestens
            <paramref name="count"/> Zeichen erstreckt, UTF-8-Text ist. Die Methode bezieht das Byte-Order-Mark (BOM)
            in die Prüfung ein.
            </summary>
            <param name="fileInfo">Ein <see cref="T:System.IO.FileInfo"/>-Objekt, das auf die zu überprüfende Datei verweist.</param>
            <param name="count">Die Anzahl der mindestens zu überprüfenden Buchstaben. Wenn dem Parameter eine negative Zahl übergeben 
            wird oder wenn <paramref name="count"/> größer ist als die
            Länge der Daten in der angegebenen Datei, wird die gesamte Datei überprüft. Wird dem Parameter <c>0</c> übergeben, überprüft 
            die Methode nur das Byte-Order-Mark (BOM).</param>
            
            <returns><c>true</c>, wenn der überprüfte Dateiabschnitt UTF-8-Text darstellt, andernfalls <c>false</c>.
            Wenn die Methode ein UTF-8-BOM findet, wird in jedem Fall <c>true</c> zurückgegeben. Wenn <paramref name="count"/>&#160;<c>0</c> ist 
            und kein UTF-8-BOM gefunden wird, wird <c>false</c> zurückgegeben.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileInfo"/> ist <c>null</c>.</exception>
            <exception cref="T:System.IO.IOException">E/A Fehler.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.FileInfoExtension.IsUtf8Valid(System.IO.FileInfo,System.Int32)">
            <summary>
            Testet, ob der Abschnitt der durch <paramref name="fileInfo"/> angegebenen Datei, der sich vom Dateianfang über mindestens
            <paramref name="count"/> Zeichen erstreckt, gültiges UTF-8 darstellt.
            </summary>
            
            <param name="fileInfo">Ein <see cref="T:System.IO.FileInfo"/>-Objekt, das auf die zu überprüfende Datei verweist.</param>
            <param name="count">Die Anzahl der mindestens zu überprüfenden Buchstaben. Wenn dem Parameter eine negative Zahl übergeben 
            wird (Default) oder wenn <paramref name="count"/> größer ist als die
            Länge der Daten in der angegebenen Datei, wird die gesamte Datei überprüft. Der Wert <c>0</c> ist nicht erlaubt.</param>
            <returns><c>true</c>, wenn der überprüfte Dateiabschnitt gültiges UTF-8 darstellt, andernfalls <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fileInfo"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> ist <c>0</c>.</exception>
            <exception cref="T:System.IO.IOException">E/A Fehler.</exception>
        </member>
        <member name="T:FolkerKinzel.Strings.HashType">
            <summary>
            Benannte Konstanten, um die Art eines Hashcodes für Zeichenfolgen festzulegen.
            </summary>
        </member>
        <member name="F:FolkerKinzel.Strings.HashType.Ordinal">
            <summary>
            Ordinalvergleich der Zeichen.
            </summary>
        </member>
        <member name="F:FolkerKinzel.Strings.HashType.OrdinalIgnoreCase">
            <summary>
            Ordinalvergleich der Zeichen ohne Berücksichtigung der Groß- und Kleinschreibung.
            </summary>
        </member>
        <member name="F:FolkerKinzel.Strings.HashType.AlphaNumericIgnoreCase">
            <summary>
            Nur Buchstaben und Dezimalziffern werden gehasht. Die Groß- und Kleinschreibung wird nicht berücksichtigt.
            </summary>
        </member>
        <member name="T:FolkerKinzel.Strings.Intls.Utf8Validator">
            <summary>
            Provides methods to examine data in order to see whether it is UTF-8 text.
            </summary>
        </member>
        <member name="M:FolkerKinzel.Strings.Intls.Utf8Validator.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:FolkerKinzel.Strings.Intls.Utf8Validator.IsUtf8(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
            Tests whether the byte sequence of <paramref name="stream"/> that starts with the current <see cref="P:System.IO.Stream.Position"/>
            and is at least <paramref name="count"/> characters long is UTF-8 text. The method takes the Byte Order Mark (BOM)
            into account.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to examine.</param>
            <param name="count">The number of characters to examine at least. If 
            <paramref name="count"/> is larger than <paramref name="stream"/> has data, <paramref name="stream"/> is
            examined until EOF. Passing a negative number to this parameter lets the method examine the whole 
            <paramref name="stream"/> from the current
            position until EOF. Passing <c>0</c> lets the method examine the BOM only.</param>
            <param name="leaveOpen"><c>false</c> to let the method close the <paramref name="stream"/>, <c>true</c> 
            otherwise.</param>
            <returns><c>true</c> if <paramref name="stream"/> might be UTF-8 text, otherwise <c>false</c>.
            If the method finds a UTF-8 BOM, it always returns <c>true</c>. If <paramref name="count"/> is 
            <c>0</c> and there's no BOM, it returns <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is <c>null</c>.</exception>
            <exception cref="T:System.IO.IOException">I/O error.</exception>
            <exception cref="T:System.ObjectDisposedException"><paramref name="stream"/> was already
            closed.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="stream"/> is not readable or <paramref name="stream"/>
            does not support seek operations.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Intls.Utf8Validator.IsUtf8Valid(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
            Tests whether the <see cref="T:System.Byte"/> sequence of <paramref name="stream"/> that starts with the current 
            <see cref="P:System.IO.Stream.Position"/>
            and is at least <paramref name="count"/> characters long is valid UTF-8 text.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to examine.</param>
            <param name="count">The number of characters to examine from the <paramref name="stream"/> at least. If 
            <paramref name="count"/> is larger than <paramref name="stream"/> has data, <paramref name="stream"/> is
            examined until EOF. Passing a negative number to this parameter lets the method examine from the current
            position until EOF. <c>0</c> is not allowed.</param>
            <param name="leaveOpen"><c>false</c> to let the method close the <paramref name="stream"/>, <c>true</c> 
            otherwise.</param>
            <returns><c>true</c> if the examined sequence in <paramref name="stream"/> is valid UTF-8 text, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is <c>0</c>.</exception>
            <exception cref="T:System.IO.IOException">I/O error.</exception>
            <exception cref="T:System.ObjectDisposedException"><paramref name="stream"/> was already
            closed.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="stream"/> is not readable.</exception>
        </member>
        <member name="T:FolkerKinzel.Strings.Polyfills.ReadOnlyMemoryPolyfillExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.ReadOnlyMemory`1">ReadOnlyMemory&lt;Char&gt;</see>-Struktur, die in .NET Framework 4.5, .NET Standard 2.0 
            und .NET Standard 2.1 als
            Polyfills für Methoden aus aktuellen .NET-Versionen dienen.
            </summary>
            <remarks>
            Die Methoden dieser Klasse sollten ausschließlich in der Erweiterungsmethodensyntax verwendet zu werden, um die 
            in moderneren Frameworks vorhandenen Originalmethoden der<see cref="T:System.ReadOnlyMemory`1">ReadOnlyMemory&lt;Char&gt;</see>-Struktur zu simulieren.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlyMemoryPolyfillExtension.Trim(System.ReadOnlyMemory{System.Char})">
            <summary>
            Entfernt alle führenden und nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.
            </summary>
            <param name="memory">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
            <returns>Der zugeschnittene Zeichenspeicherbereich.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlyMemoryPolyfillExtension.TrimStart(System.ReadOnlyMemory{System.Char})">
            <summary>
            Entfernt alle führenden Leerzeichen aus einem schreibgeschützten Speicherbereich.
            </summary>
            <param name="memory">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
            <returns>Der zugeschnittene Zeichenspeicherbereich.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlyMemoryPolyfillExtension.TrimEnd(System.ReadOnlyMemory{System.Char})">
            <summary>
            Entfernt alle nachfolgenden Leerzeichen aus einem schreibgeschützten Zeichenspeicherbereich.
            </summary>
            <param name="memory">Der Quellspeicher, aus dem die Zeichen entfernt werden.</param>
            <returns>Der zugeschnittene Zeichenspeicherbereich.</returns>
        </member>
        <member name="T:FolkerKinzel.Strings.Polyfills.ReadOnlySpanExtensionPolyfillExtension">
            <summary>
            Erweiterungsmethoden, die als Polyfills für die Erweiterungsmethoden der Klasse <see cref="T:FolkerKinzel.Strings.ReadOnlySpanExtension"/>
            dienen.
            </summary>
            <remarks>
            Die Polyfills sind verfügbar für .NET Framework 4.5 und .NET Standard 2.0.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanExtensionPolyfillExtension.LastIndexOf(System.ReadOnlySpan{System.Char},System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge <paramref name="span"/> an. Die Suche beginnt an einer angegebenen Zeichenposition 
            und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenspanne. Ein Parameter gibt den Typ des bei der Suche nach der angegebenen 
            Zeichenfolge auszuführenden Vergleichs an.
            </summary>
            <param name="span">Die zu durchsuchende Zeichenspanne.</param>
            <param name="value">Der zu suchende <see cref="T:System.String"/> oder <c>null</c>.</param>
            <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex"/> bis zum Anfang von <paramref name="span"/> fortgesetzt.</param>
            <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
            <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
            <returns>Die nullbasierte Anfangsindexposition des <paramref name="value"/>-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht 
            gefunden wurde oder <paramref name="span"/> leer ist.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="count"/> ist ein negativer Wert
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="span"/> ist nicht <see cref="P:System.ReadOnlySpan`1.Empty"/>, und <paramref name="startIndex"/> ist ein negativer Wert.
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="span"/> ist nicht <see cref="P:System.ReadOnlySpan`1.Empty"/>, und <paramref name="startIndex"/> ist größer als die Länge von <paramref name="span"/>.
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="span"/> ist nicht <see cref="P:System.ReadOnlySpan`1.Empty"/>, und <paramref name="startIndex"/> + 1 - <paramref name="count"/> gibt eine Position an, 
            die nicht innerhalb von <paramref name="span"/> liegt.
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="span"/> ist <see cref="P:System.ReadOnlySpan`1.Empty"/>, und <paramref name="startIndex"/> ist kleiner als -1 oder größer als 0.
            </para>
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="comparisonType"/> ist kein gültiger <see cref="T:System.StringComparison"/>-Wert.
            </exception>
        </member>
        <member name="T:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see>-Struktur, die in .NET Framework 4.5, .NET Standard 2.0 
            und .NET Standard 2.1 als
            Polyfills für Methoden aus aktuellen .NET-Versionen dienen.
            </summary>
            <remarks>
            Die Methoden dieser Klasse sollten ausschließlich in der Erweiterungsmethodensyntax verwendet zu werden, um die 
            in moderneren Frameworks vorhandenen Originalmethoden der<see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see>-Struktur zu simulieren.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension.Equals(System.ReadOnlySpan{System.Char},System.String,System.StringComparison)">
            <summary>
            Bestimmt, ob dieser <paramref name="span"/> und der angegebene <paramref name="other"/>-<see cref="T:System.String"/> 
            dieselben Zeichen aufweisen, wenn sie mit der angegebenen <paramref name="comparisonType"/>-Option verglichen
            werden.
            </summary>
            <param name="span">Die Quellspanne.</param>
            <param name="other">Der Wert, der mit der Quellspanne verglichen werden soll.</param>
            <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie <paramref name="span"/> und 
            <paramref name="other"/> verglichen werden.</param>
            <returns><c>true</c>, sofern identisch, andernfalls <c>false</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension.Contains(System.ReadOnlySpan{System.Char},System.String,System.StringComparison)">
            <summary>
            Gibt an, ob ein angegebener Wert innerhalb einer schreibgeschützten Zeichenspanne auftritt.
            </summary>
            <param name="span">Die Quellspanne.</param>
            <param name="value">Der innerhalb der Quellspanne zu suchende Wert. <paramref name="value"/> darf <c>null</c> sein.</param>
            <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie die Zeichen in <paramref name="span"/> und 
            <paramref name="value"/> verglichen werden.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> innerhalb der Spanne auftritt, andernfalls <c>false</c>.</returns>
            <remarks>Verfügbar für .NET Framework 4.5 und .NET Standard 2.0.</remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension.Contains(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Gibt an, ob ein angegebenes Unicodezeichen in der Spanne gefunden wird. 
            Zum Vergleich wird MemoryExtensions.IndexOf(this ReadOnlySpan&lt;T&gt;, ReadOnlySpan&lt;T&gt;) verwendet.
            </summary>
            <param name="span">Die zu durchsuchende Spanne.</param>
            <param name="value">Das zu suchende Unicodezeichen.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> gefunden wurde, andernfalls <c>false</c>.</returns>
            <remarks>Verfügbar für .NET Framework 4.5, .NET Standard 2.0 und .NET Standard 2.1.</remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge in <paramref name="span"/> an. 
            Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.
            </summary>
            <param name="span">Die zu durchsuchende Zeichenspanne.</param>
            <param name="value">Die zu suchende Zeichenfolge.</param>
            <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
            <returns>Die nullbasierte Indexposition des <paramref name="value"/>-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> ist kein gültiger <see cref="T:System.StringComparison"/>-Wert.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension.LastIndexOf(System.ReadOnlySpan{System.Char},System.String,System.StringComparison)">
            <summary>
            Gibt den NULL-basierten Index des letzten Vorkommens einer angegebenen Zeichenfolge in <paramref name="span"/> an. 
            Ein Parameter gibt den Typ der Suche für die angegebene Zeichenfolge an.
            </summary>
            <param name="span">Die zu durchsuchende Zeichenspanne.</param>
            <param name="value">Der zu suchende <see cref="T:System.String"/> oder <c>null</c>.</param>
            <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
            <returns>Die nullbasierte Indexposition des <paramref name="value"/>-Parameters, wenn diese Zeichenfolge gefunden wurde, andernfalls -1.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> ist kein gültiger <see cref="T:System.StringComparison"/>-Wert.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension.StartsWith(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Bestimmt, ob eine schreibgeschützte Zeichenspanne mit einem angegebenen <see cref="T:System.String"/> beginnt.
            </summary>
            <param name="span">Die Quellspanne.</param>
            <param name="value">Der <see cref="T:System.String"/>, der mit dem Anfang der Quellspanne verglichen werden soll.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> mit dem Anfang von <paramref name="span"/> übereinstimmt,
            andernfalls <c>false</c>.</returns>
            <remarks>
            <para>
            Die Methode führt einen Ordinalzeichenvergleich durch. Wenn <paramref name="value"/>&#160;<c>null</c> oder <see cref="F:System.String.Empty"/> ist
            wird <c>true</c> zurückgegeben.
            </para>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para></remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension.StartsWith(System.ReadOnlySpan{System.Char},System.String,System.StringComparison)">
            <summary>
            Bestimmt, ob eine schreibgeschützte Zeichenspanne mit einem angegebenen <see cref="T:System.String"/> beginnt,
            wenn sie mit einem angegebenen <see cref="T:System.StringComparison"/> verglichen wird.
            </summary>
            <param name="span">Die Quellspanne.</param>
            <param name="value">Der <see cref="T:System.String"/>, der mit dem Anfang der Quellspanne verglichen werden soll.</param>
            <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie <paramref name="span"/> und 
            <paramref name="value"/> verglichen werden.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> mit dem Anfang von <paramref name="span"/> übereinstimmt,
            andernfalls <c>false</c>.</returns>
            <remarks>
            <para>
            Die Methode führt einen Ordinalzeichenvergleich durch. Wenn <paramref name="value"/>&#160;<c>null</c> oder <see cref="F:System.String.Empty"/> ist
            wird <c>true</c> zurückgegeben.
            </para>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> ist kein definierter <see cref="T:System.StringComparison"/>-Wert.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension.EndsWith(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Bestimmt, ob eine schreibgeschützte Zeichenspanne mit einem angegebenen <see cref="T:System.String"/> endet.
            </summary>
            <param name="span">Die Quellspanne.</param>
            <param name="value">Der <see cref="T:System.String"/>, der mit dem Ende der Quellspanne verglichen werden soll.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> mit dem Ende von <paramref name="span"/> übereinstimmt,
            andernfalls <c>false</c>.</returns>
            <remarks>
            <para>
            Die Methode führt einen Ordinalzeichenvergleich durch. Wenn <paramref name="value"/>&#160;<c>null</c> oder <see cref="F:System.String.Empty"/> ist
            wird <c>true</c> zurückgegeben.
            </para>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para></remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.ReadOnlySpanPolyfillExtension.EndsWith(System.ReadOnlySpan{System.Char},System.String,System.StringComparison)">
            <summary>
            Bestimmt, ob eine schreibgeschützte Zeichenspanne mit einem angegebenen <see cref="T:System.String"/> endet,
            wenn sie mit einem angegebenen <see cref="T:System.StringComparison"/> verglichen wird.
            </summary>
            <param name="span">Die Quellspanne.</param>
            <param name="value">Der <see cref="T:System.String"/>, der mit dem Ende der Quellspanne verglichen werden soll.</param>
            <param name="comparisonType">Ein Enumerationswert, der bestimmt, wie <paramref name="span"/> und 
            <paramref name="value"/> verglichen werden.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> mit dem Ende von <paramref name="span"/> übereinstimmt,
            andernfalls <c>false</c>.</returns>
            <remarks>
            <para>
            Wenn <paramref name="value"/>&#160;<c>null</c> oder <see cref="F:System.String.Empty"/> ist
            wird <c>true</c> zurückgegeben.
            </para>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> ist kein definierter <see cref="T:System.StringComparison"/>-Wert.</exception>
        </member>
        <member name="T:FolkerKinzel.Strings.Polyfills.StringBuilderExtensionPolyfillExtension">
            <summary>
            Erweiterungsmethoden, die als Polyfills für die Erweiterungsmethoden der Klasse <see cref="T:FolkerKinzel.Strings.StringBuilderExtension"/>
            dienen.
            </summary>
            <remarks>
            Die Polyfills sind verfügbar für .NET Framework 4.5 und .NET Standard 2.0.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderExtensionPolyfillExtension.ReplaceWhiteSpaceWith(System.Text.StringBuilder,System.String,System.Boolean)">
            <summary>
            Ersetzt in <paramref name="builder"/> alle Sequenzen von Leerzeichen durch <paramref name="replacement"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="replacement">Ein <see cref="T:System.String"/>, durch den die Leerzeichen-Sequenzen
            ersetzt werden, oder <c>null</c>, um alle Leerraumzeichen zu entfernen.</param>
            <param name="skipNewLines">Übergeben Sie <c>true</c>, um Zeilenumbruchzeichen von der 
            Ersetzung auszunehmen. Der Standardwert ist <c>false</c>.</param>
            <returns>Eine Referenz auf <paramref name="builder"/></returns>
            <remarks>
            <para>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen und arbeitet
            damit gründlicher als 
            <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">Regex.Replace(string input, @"\s+", string replacement)</see>.
            </para>
            <para>Zur Identifizierung von Zeilenumbruchzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/>
            verwendet.
            </para>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para>
            
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderExtensionPolyfillExtension.ReplaceWhiteSpaceWith(System.Text.StringBuilder,System.String,System.Int32,System.Boolean)">
            <summary>
            Ersetzt in einem Abschnitt von <paramref name="builder"/>, der bei <paramref name="startIndex"/> beginnt
            und bis zum Ende von <paramref name="builder"/> reicht, alle Sequenzen von Leerzeichen durch <paramref name="replacement"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="replacement">Ein <see cref="T:System.String"/>, durch den die Leerzeichen-Sequenzen
            ersetzt werden, oder <c>null</c>, um alle Leerraumzeichen zu entfernen.</param>
            <param name="skipNewLines">Übergeben Sie <c>true</c>, um Zeilenumbruchzeichen von der 
            Ersetzung auszunehmen. Der Standardwert ist <c>false</c>.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem der Abschnitt beginnt,
            in dem die Ersetzungen vorgenommen werden.</param>
            <returns>Eine Referenz auf <paramref name="builder"/></returns>
            <remarks>
            <para>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen und arbeitet
            damit gründlicher als 
            <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">Regex.Replace(string input, @"\s+", string replacement)</see>.
            </para>
            <para>Zur Identifizierung von Zeilenumbruchzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/>
            verwendet.
            </para>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para>
            
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="startIndex"/> ist kleiner als 0 oder größer als die Anzahl der Zeichen in <paramref name="builder"/>.
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderExtensionPolyfillExtension.ReplaceWhiteSpaceWith(System.Text.StringBuilder,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Ersetzt in einem Abschnitt von <paramref name="builder"/>, der bei <paramref name="startIndex"/> beginnt
            und <paramref name="count"/> Zeichen umfasst, alle Sequenzen von Leerzeichen durch <paramref name="replacement"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="replacement">Ein <see cref="T:System.String"/>, durch den die Leerzeichen-Sequenzen
            ersetzt werden, oder <c>null</c>, um alle Leerraumzeichen zu entfernen.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem der Abschnitt beginnt,
            in dem die Ersetzungen vorgenommen werden.</param>
            <param name="count">Die Länge des Abschnitts, in dem Ersetzungen vorgenommen werden.</param>
            <param name="skipNewLines">Übergeben Sie <c>true</c>, um Zeilenumbruchzeichen von der 
            Ersetzung auszunehmen. Der Standardwert ist <c>false</c>.</param>
            <returns>Eine Referenz auf <paramref name="builder"/></returns>
            <remarks>
            <para>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen und arbeitet
            damit gründlicher als 
            <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">Regex.Replace(string input, @"\s+", string replacement)</see>.
            </para>
            <para>Zur Identifizierung von Zeilenumbruchzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/>
            verwendet.
            </para>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para>
            
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/> ist kleiner als 0
            </para>
            <para>- oder -</para>
            <para>
            <paramref name="startIndex"/> + <paramref name="count"/>
            ist größer als die Anzahl der Zeichen in <paramref name="builder"/>.
            </para>
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderExtensionPolyfillExtension.NormalizeNewLinesTo(System.Text.StringBuilder,System.String)">
            <summary>
            Ersetzt alle Zeilenumbrüche in <paramref name="builder"/> durch <paramref name="newLine"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="newLine">Ein <see cref="T:System.String"/>, durch den jeder Zeilenumbruch
            ersetzt wird, oder <c>null</c>, um alle Zeilenumbrüche zu entfernen.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <remarks>
            <para>
            Für die Identifizierung von Zeilenwechselzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/> 
            verwendet. Die Sequenzen CRLF und LFCR werden als ein Zeilenumbruch behandelt.
            </para>
            <note type="caution">
            Diese Methode unterscheidet sich von <see cref="M:FolkerKinzel.Strings.StringBuilderExtension.ReplaceLineEndings(System.Text.StringBuilder,System.String)"/> dahingehend,
            dass sie zusätzlich LFCR-Sequenzen und Vertical Tab (VT: U+000B) als Zeilenwechsel behandelt.
            </note>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="T:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.Text.StringBuilder"/>-Klasse, die in .NET Framework 4.5 und .NET Standard 2.0 als
            Polyfills für Methoden aus aktuellen .NET-Versionen dienen.
            </summary>
            <remarks>
            Die Methoden dieser Klasse sollten ausschließlich in der Erweiterungsmethodensyntax verwendet zu werden, um die 
            in moderneren Frameworks vorhandenen Originalmethoden der <see cref="T:System.Text.StringBuilder"/>-Klasse zu simulieren. Um dem Verhalten der 
            Originalmethoden zu entsprechen, werfen diese Erweiterungsmethoden eine <see cref="T:System.NullReferenceException"/>, wenn sie auf 
            <c>null</c> aufgerufen werden.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension.AppendJoin(System.Text.StringBuilder,System.Char,System.String[])">
            <summary>
            Verkettet die Zeichenfolgen des bereitgestellten Arrays, wobei das angegebene als Trennzeichen zu verwendende Zeichen 
            zwischen den einzelnen Zeichenfolgen verwendet wird, und fügt dann das Ergebnis an <paramref name="builder"/>
            an.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, an den Zeichen angefügt werden.</param>
            <param name="separator">Das Zeichen, das als Trennzeichen verwendet werden soll. <paramref name="separator"/>
            ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values"/> mehr als ein Element enthält.</param>
            <param name="values">Ein Array, das die zu verkettenden Zeichenfolgen enthält, die an <paramref name="builder"/>
            angefügt werden sollen.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension.AppendJoin(System.Text.StringBuilder,System.Char,System.Object[])">
            <summary>
            Verkettet die Zeichenfolgendarstellungen der Elemente im bereitgestellten Array von Objekten, wobei das angegebene als 
            Trennzeichen zu verwendende Zeichen zwischen den einzelnen Elementen verwendet wird, und fügt dann das Ergebnis an 
            <paramref name="builder"/> an.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, an den Zeichen angefügt werden.</param>
            <param name="separator">Das Zeichen, das als Trennzeichen verwendet werden soll. <paramref name="separator"/>
            ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values"/> mehr als ein Element enthält.</param>
            <param name="values">Ein Array, das die Objekte enthält, deren zu verkettende Zeichenfolgendarstellung an <paramref name="builder"/>
            angefügt werden soll.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension.AppendJoin``1(System.Text.StringBuilder,System.Char,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Verkettet die Zeichenfolgendarstellungen der Elemente in der bereitgestellten Sammlung, wobei das angegebene als 
            Trennzeichen zu verwendende Zeichen zwischen den einzelnen Elementen verwendet wird, und fügt dann das Ergebnis an 
            <paramref name="builder"/> an.
            </summary>
            <typeparam name="T">Generischer Typparameter, der den Typ der Elemente in <paramref name="values"/> angibt.</typeparam>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, an den Zeichen angefügt werden.</param>
            <param name="separator">Das Zeichen, das als Trennzeichen verwendet werden soll. <paramref name="separator"/>
            ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values"/> mehr als ein Element enthält.</param>
            <param name="values">Eine Sammlung, die die Objekte enthält, deren zu verkettende Zeichenfolgendarstellung an <paramref name="builder"/>
            angefügt werden soll.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension.AppendJoin(System.Text.StringBuilder,System.String,System.String[])">
            <summary>
            Verkettet die Zeichenfolgen des bereitgestellten Arrays, wobei das angegebene Trennzeichen 
            zwischen den einzelnen Zeichenfolgen verwendet wird, und fügt dann das Ergebnis an <paramref name="builder"/>
            an.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, an den Zeichen angefügt werden.</param>
            <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator"/>
            ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values"/> mehr als ein Element enthält.</param>
            <param name="values">Ein Array, das die zu verkettenden Zeichenfolgen enthält, die an <paramref name="builder"/>
            angefügt werden sollen.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension.AppendJoin(System.Text.StringBuilder,System.String,System.Object[])">
            <summary>
            Verkettet die Zeichenfolgendarstellungen der Elemente im bereitgestellten Array von Objekten, wobei das angegebene
            Trennzeichen zwischen den einzelnen Elementen verwendet wird, und fügt dann das Ergebnis an 
            <paramref name="builder"/> an.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, an den Zeichen angefügt werden.</param>
            <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator"/>
            ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values"/> mehr als ein Element enthält.</param>
            <param name="values">Ein Array, das die Objekte enthält, deren zu verkettende Zeichenfolgendarstellung an <paramref name="builder"/>
            angefügt werden soll.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension.AppendJoin``1(System.Text.StringBuilder,System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Verkettet die Zeichenfolgendarstellungen der Elemente in der bereitgestellten Sammlung, wobei das angegebene
            Trennzeichen zwischen den einzelnen Elementen verwendet wird, und fügt dann das Ergebnis an 
            <paramref name="builder"/> an.
            </summary>
            <typeparam name="T">Generischer Typparameter, der den Typ der Elemente in <paramref name="values"/> angibt.</typeparam>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, an den Zeichen angefügt werden.</param>
            <param name="separator">Die Zeichenfolge, die als Trennzeichen verwendet werden soll. <paramref name="separator"/>
            ist in den verknüpften Zeichenfolgen nur enthalten, wenn <paramref name="values"/> mehr als ein Element enthält.</param>
            <param name="values">Eine Sammlung, die die Objekte enthält, deren zu verkettende Zeichenfolgendarstellung an <paramref name="builder"/>
            angefügt werden soll.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="values"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension.Append(System.Text.StringBuilder,System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Fügt eine Kopie einer Teilzeichenfolge, die aus einem als Argument übergebenen <see cref="T:System.Text.StringBuilder"/> stammt, an 
            den vorhandenen Inhalt von <paramref name="builder"/> an.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt geändert wird.</param>
            <param name="value">Der <see cref="T:System.Text.StringBuilder"/>, von dessen Inhalt ein Teil kopiert wird.</param>
            <param name="startIndex">Der NULL-basierte Index in <paramref name="value"/>, an dem der zu kopierende
            Abschnitt beginnt.</param>
            <param name="count">Die Anzahl der zu kopierenden Zeichen.</param>
            <returns>Eine Referenz auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/>
            sind kleiner als 0
            </para>
            <para>
            - oder -
            </para>
            <para>
            die Summe <paramref name="startIndex"/> + <paramref name="count"/> ist größer als die Anzahl
            der Zeichen in <paramref name="value"/>.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> ist <c>null</c> und <paramref name="startIndex"/> oder <paramref name="count"/>
            haben einen Wert, der größer als 0 ist.
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension.Append(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})">
            <summary>
            Fügt die Zeichenfolgendarstellung eines festgelegten schreibgeschützten Zeichenspeicherbereichs an einen <see cref="T:System.Text.StringBuilder"/> an.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, an den die Zeichen angefügt werden.</param>
            <param name="value">Der anzufügende schreibgeschützte Zeichenspeicherbereich.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Bei der Erhöhung der Kapazität von <paramref name="builder"/>
            würde <see cref="P:System.Text.StringBuilder.MaxCapacity"/> überschritten.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringBuilderPolyfillExtension.Insert(System.Text.StringBuilder,System.Int32,System.ReadOnlySpan{System.Char})">
            <summary>
            Fügt den Inhalt einer schreibgeschützten Zeichenspanne an der angegebenen Zeichenposition in <paramref name="builder"/> ein.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, in den Zeichen eingefügt werden.</param>
            <param name="index">Der nullbasierte Index in <paramref name="builder"/>, an dem die Einfügung beginnt.</param>
            <param name="value">Die einzufügende Zeichenspanne.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Einfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> ist kleiner als 0 oder größer
            als die Länge von <paramref name="builder"/>.</exception>
        </member>
        <member name="T:FolkerKinzel.Strings.Polyfills.StringExtensionPolyfillExtension">
            <summary>
            Erweiterungsmethoden, die als Polyfills für die Erweiterungsmethoden der Klasse <see cref="T:FolkerKinzel.Strings.StringExtension"/>
            dienen.
            </summary>
            <remarks>
            Die Polyfills sind verfügbar für .NET Framework 4.5 und .NET Standard 2.0.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringExtensionPolyfillExtension.ReplaceWhiteSpaceWith(System.String,System.String,System.Boolean)">
            <summary>
            Erzeugt einen neuen <see cref="T:System.String"/>, in dem alle Sequenzen von Leerzeichen in <paramref name="s"/> durch 
            <paramref name="replacement"/> ersetzt sind.
            </summary>
            <param name="s">Der Quell-<see cref="T:System.String"/>.</param>
            <param name="replacement">Ein <see cref="T:System.String"/>, durch den die Leerraumzeichen-Sequenzen
            ersetzt werden, oder <c>null</c>, um alle Leerzeichen zu entfernen.</param>
            <param name="skipNewLines">Übergeben Sie <c>true</c>, um Zeilenumbruchzeichen von der 
            Ersetzung auszunehmen. Der Standardwert ist <c>false</c>.</param>
            <returns>Ein neuer <see cref="T:System.String"/>, in in dem alle Sequenzen von Leerzeichen in <paramref name="s"/> durch 
            <paramref name="replacement"/> ersetzt sind. Wenn <paramref name="s"/> kein Leerzeichen enthält, wird <paramref name="s"/>
            zurückgegeben.</returns>
            <remarks>
            <para>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen und arbeitet
            damit gründlicher als 
            <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">Regex.Replace(string input, @"\s+", string replacement)</see>.
            </para>
            <para>Zur Identifizierung von Zeilenumbruchzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/>
            verwendet.
            </para>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para>
            
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringExtensionPolyfillExtension.NormalizeNewLinesTo(System.String,System.String)">
            <summary>
            Erzeugt einen neuen <see cref="T:System.String"/>, in dem alle Zeilenumbrüche
            durch <paramref name="newLine"/> ersetzt sind.
            </summary>
            <param name="s">Der Quellstring.</param>
            <param name="newLine">Ein <see cref="T:System.String"/>, durch den jeder Zeilenumbruch
            ersetzt wird, oder <c>null</c>, um alle Zeilenumbrüche zu entfernen.</param>
            <returns>Ein neuer <see cref="T:System.String"/>, in dem alle Zeilenumbrüche
            durch <paramref name="newLine"/> ersetzt sind. Wenn <paramref name="s"/> keine Zeilenwechselzeichen
            enthält, wird <paramref name="s"/> unverändert zurückgegeben.</returns>
            <remarks>
            <para>
            Für die Identifizierung von Zeilenwechselzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/> 
            verwendet. Die Sequenzen CRLF und LFCR werden als ein Zeilenumbruch behandelt.
            </para>
            <note type="caution">
            Diese Methode unterscheidet sich von <see cref="M:FolkerKinzel.Strings.StringExtension.ReplaceLineEndings(System.String,System.String)"/> dahingehend,
            dass sie zusätzlich LFCR-Sequenzen und Vertical Tab (VT: U+000B) als Zeilenwechsel behandelt.
            </note>
            <para>
            Diese Überladung ist nützlich, da die implizite Umwandlung von <see cref="T:System.String"/> in 
            <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see> erst ab .NET Standard 2.1 unterstützt wird.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="T:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.String"/>-Klasse, die in .NET Framework 4.5 und .NET Standard 2.0 als
            Polyfills für Methoden aus aktuellen .NET-Versionen dienen.
            </summary>
            <remarks>
            Die Methoden dieser Klasse sollten ausschließlich in der Erweiterungsmethodensyntax verwendet zu werden, um die 
            in moderneren Frameworks vorhandenen Originalmethoden der <see cref="T:System.String"/>-Klasse zu simulieren. Um dem Verhalten der 
            Originalmethoden zu entsprechen, werfen diese Erweiterungsmethoden eine <see cref="T:System.NullReferenceException"/>, wenn sie auf 
            einem Null-String aufgerufen werden.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.Contains(System.String,System.Char,System.StringComparison)">
            <summary>
            Gibt mithilfe der festgelegten Vergleichsregeln einen Wert zurück, der angibt, ob ein angegebenes Zeichen innerhalb der Zeichenfolge auftritt.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="value">Das zu suchende Zeichen.</param>
            <param name="comparisonType">Ein Enumerationswert, der die für den Vergleich zu verwendende Regel angibt.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> innerhalb dieser Zeichenfolge auftritt, andernfalls <c>false</c>.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> ist kein gültiger <see cref="T:System.StringComparison"/>-Wert.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.Contains(System.String,System.Char)">
            <summary>
            Gibt einen Wert zurück, der angibt, ob ein angegebenes Zeichen in der Zeichenfolge vorkommt.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="value">Das zu suchende Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> innerhalb dieser Zeichenfolge auftritt, andernfalls <c>false</c>.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich aus.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.Contains(System.String,System.String,System.StringComparison)">
            <summary>
            Gibt mithilfe der festgelegten Vergleichsregeln einen Wert zurück, der angibt, ob eine angegebene Zeichenfolge innerhalb von <paramref name="s"/>
            auftritt.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="value">Die zu suchende Zeichenfolge.</param>
            <param name="comparisonType">Ein Enumerationswert, der die für den Vergleich zu verwendende Regel angibt.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> innerhalb dieser Zeichenfolge auftritt, andernfalls <c>false</c>.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.IndexOf(System.String,System.Char,System.StringComparison)">
            <summary>
            Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Unicode-Zeichens in dieser Zeichenfolge an. 
            Ein Parameter gibt den Typ der Suche für das angegebene Zeichen an.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="value">Das zu suchende Zeichen.</param>
            <param name="comparisonType">Ein Enumerationswert, der die Regeln für die Suche festlegt.</param>
            <returns>Der nullbasierte Index von <paramref name="value"/>, wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> ist kein gültiger <see cref="T:System.StringComparison"/>-Wert.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.Split(System.String,System.Char,System.StringSplitOptions)">
            <summary>
            Hier wird eine Zeichenfolge anhand eines angegebenen Trennzeichens und optional von Optionen in Teilzeichenfolgen unterteilt.
            </summary>
            <param name="s">Der zu teilende <see cref="T:System.String"/>.</param>
            <param name="separator">Ein Zeichen, das die Teilzeichenfolgen in <paramref name="s"/> trennt.</param>
            <param name="options">Dies ist ein Enumerationswert, der angibt, ob leere Teilzeichenfolgen 
            eingeschlossen werden sollen.</param>
            <returns>Ein Array, dessen Elemente die Teilzeichenfolgen von <paramref name="s"/> enthält, die durch
            <paramref name="separator"/> getrennt sind.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.Split(System.String,System.Char,System.Int32,System.StringSplitOptions)">
            <summary>
            Hier wird eine Zeichenfolge in eine maximale Anzahl von Teilzeichenfolgen anhand 
            des angegebenen Ersatztrennzeichens unterteilt, wobei optional leere Teilzeichenfolgen aus dem Ergebnis ausgelassen werden.
            </summary>
            <param name="s">Der zu teilende <see cref="T:System.String"/>.</param>
            <param name="separator">Ein Zeichen, das die Teilzeichenfolgen in <paramref name="s"/> trennt.</param>
            <param name="count">Die maximale Anzahl der im Array erwarteten Elemente.</param>
            <param name="options">Dies ist ein Enumerationswert, der angibt, ob leere Teilzeichenfolgen 
            eingeschlossen werden sollen.</param>
            <returns>Ein Array, das maximal <paramref name="count"/> Teilzeichenfolgen von <paramref name="s"/> enthält, die durch
            <paramref name="separator"/> getrennt sind.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> ist negativ.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.Split(System.String,System.String,System.Int32,System.StringSplitOptions)">
            <summary>
            Teilt eine Zeichenfolge anhand einer angegebenen Trennzeichenfolge und optional von Optionen in die angegebene maximale Anzahl von Teilzeichenfolgen.
            </summary>
            <param name="s">Der zu splittende <see cref="T:System.String"/>.</param>
            <param name="separator">Eine Zeichenfolge, die die Teilzeichenfolgen in <paramref name="s"/> trennt.</param>
            <param name="count">Die maximale Anzahl der im Array erwarteten Elemente.</param>
            <param name="options">Dies ist ein Enumerationswert, der angibt, ob leere Teilzeichenfolgen 
            eingeschlossen werden sollen.</param>
            <returns>Ein Array, das maximal <paramref name="count"/> Teilzeichenfolgen von <paramref name="s"/> enthält, die durch
            <paramref name="separator"/> getrennt sind.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> ist negativ.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.Split(System.String,System.String,System.StringSplitOptions)">
            <summary>
            Teilt eine Zeichenfolge anhand einer angegebenen Trennzeichenfolge und optional von Optionen in Teilzeichenfolgen.
            </summary>
            <param name="s">Der zu splittende <see cref="T:System.String"/>.</param>
            <param name="separator">Eine Zeichenfolge, die die Teilzeichenfolgen in <paramref name="s"/> trennt.</param>
            <param name="options">Dies ist ein Enumerationswert, der angibt, ob leere Teilzeichenfolgen 
            eingeschlossen werden sollen.</param>
            <returns>Ein Array, dessen Elemente die Teilzeichenfolgen von <paramref name="s"/> enthält, die durch
            <paramref name="separator"/> getrennt sind.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.StartsWith(System.String,System.Char)">
            <summary>
            Bestimmt, ob <paramref name="s"/> mit dem angegebenen Zeichen beginnt.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="value">Das zu vergleichende Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> mit dem Anfang von <paramref name="s"/> übereinstimmt, andernfalls <c>false</c>.</returns>
            <remarks>
            Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).
            </remarks>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.EndsWith(System.String,System.Char)">
            <summary>
            Bestimmt, ob <paramref name="s"/> mit dem angegebenen Zeichen endet.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="value">Das zu vergleichende Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> mit dem Ende von <paramref name="s"/> übereinstimmt, andernfalls <c>false</c>.</returns>
            <remarks>
            Diese Methode führt einen Vergleich mit der aktuellen Kultur durch (Unterscheidung nach Groß-/Kleinschreibung und Kultur sensitiv).
            </remarks>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.Polyfills.StringPolyfillExtension.Replace(System.String,System.String,System.String,System.StringComparison)">
            <summary>
            Gibt mithilfe des bereitgestellten Vergleichstyps eine neue Zeichenfolge zurück, in der alle Vorkommen einer 
            angegebenen Zeichenfolge in der aktuellen Instanz durch eine andere angegebene Zeichenfolge ersetzt wurden.
            </summary>
            <param name="s">Der zu bearbeitende <see cref="T:System.String"/>.</param>
            <param name="oldValue">Die zu ersetzende Zeichenfolge.</param>
            <param name="newValue">Die Zeichenfolge, die jedes Vorkommen von <paramref name="oldValue"/> ersetzen soll.</param>
            <param name="comparisonType">Ein Enumerationswert, der die für den Vergleich zu verwendende Regel angibt.</param>
            <returns>Eine Zeichenfolge, die der aktuellen Zeichenfolge entspricht, außer dass alle Instanzen von <paramref name="oldValue"/>
            durch <paramref name="newValue"/> ersetzt wurden. Wenn <paramref name="oldValue"/> nicht in der aktuellen Instanz gefunden wird, 
            gibt die Methode die aktuelle Instanz unverändert zurück.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="oldValue"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
            <para><paramref name="oldValue"/> ist <see cref="F:System.String.Empty"/></para>
            <para>- oder -</para>
            <para><paramref name="comparisonType"/> ist kein gültiger <see cref="T:System.StringComparison"/>-Wert.</para></exception>
        </member>
        <member name="T:FolkerKinzel.Strings.Properties.Res">
            <summary>
              Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
            </summary>
        </member>
        <member name="P:FolkerKinzel.Strings.Properties.Res.ResourceManager">
            <summary>
              Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
            </summary>
        </member>
        <member name="P:FolkerKinzel.Strings.Properties.Res.Culture">
            <summary>
              Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
              Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
            </summary>
        </member>
        <member name="P:FolkerKinzel.Strings.Properties.Res.ArgumentNullOrWhiteSpace">
            <summary>
              Sucht eine lokalisierte Zeichenfolge, die The argument is either null or empty or it consists only of white space characters. ähnelt.
            </summary>
        </member>
        <member name="P:FolkerKinzel.Strings.Properties.Res.NoBinaryDigit">
            <summary>
              Sucht eine lokalisierte Zeichenfolge, die {0} is not a binary digit. ähnelt.
            </summary>
        </member>
        <member name="P:FolkerKinzel.Strings.Properties.Res.NoDecimalDigit">
            <summary>
              Sucht eine lokalisierte Zeichenfolge, die {0} is not a decimal digit. ähnelt.
            </summary>
        </member>
        <member name="P:FolkerKinzel.Strings.Properties.Res.NoEmptyStringAllowed">
            <summary>
              Sucht eine lokalisierte Zeichenfolge, die String cannot be of zero length. ähnelt.
            </summary>
        </member>
        <member name="P:FolkerKinzel.Strings.Properties.Res.UndefinedEnumValue">
            <summary>
              Sucht eine lokalisierte Zeichenfolge, die The value is not defined. ähnelt.
            </summary>
        </member>
        <member name="T:FolkerKinzel.Strings.ReadOnlySpanExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.ReadOnlySpan`1">ReadOnlySpan&lt;Char&gt;</see>-Struktur.
            </summary>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.ContainsAny(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Gibt an, ob in einer schreibgeschüzten Zeichenspanne eines der Zeichen vorkommt,
            die der Methode in einer anderen schreibgeschützten Zeichenspanne übergeben werden.
            </summary>
            <param name="span">Die zu untersuchende Spanne.</param>
            <param name="values">Eine schreibgeschützte Zeichenspanne, die die zu suchenden Zeichen enthält.</param>
            <returns><c>true</c>, wenn in <paramref name="span"/> eines der in <paramref name="values"/> enthaltenen
            Zeichen vorkommt. Wenn <paramref name="span"/> oder <paramref name="values"/> leere Spannen sind,
            wird <c>false</c> zurückgegeben.</returns>
            <remarks>
            Wenn die Länge von <paramref name="values"/> kleiner als 5 ist, verwendet die Methode für den Vergleich 
            MemoryExtensions.IndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, ReadOnlySpan&lt;T&gt;). 
            Ist die Länge von <paramref name="values"/>
            größer, wird - um Performanceprobleme zu vermeiden - <see cref="M:System.String.IndexOfAny(System.Char[])"/> verwendet.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.ContainsAny(System.ReadOnlySpan{System.Char},System.Char,System.Char)">
            <summary>
            Gibt an, ob in einer schreibgeschüzten Zeichenspanne eines der beiden Zeichen vorkommt,
            die der Methode als Argumente übergeben werden.
            </summary>
            <param name="span">Die zu untersuchende Spanne.</param>
            <param name="value0">Das erste zu suchende Zeichen.</param>
            <param name="value1">Das zweite zu suchende Zeichen.</param>
            <returns><c>true</c>, wenn eines der zu suchenden Zeichen in der Spanne gefunden wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Für den Vergleich wird MemoryExtensions.IndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, T, T) verwendet.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.ContainsAny(System.ReadOnlySpan{System.Char},System.Char,System.Char,System.Char)">
            <summary>
            Gibt an, ob in einer schreibgeschüzten Zeichenspanne eines der drei Zeichen vorkommt,
            die der Methode als Argumente übergeben werden.
            </summary>
            <param name="span">Die zu untersuchende Spanne.</param>
            <param name="value0">Das erste zu suchende Zeichen.</param>
            <param name="value1">Das zweite zu suchende Zeichen.</param>
            <param name="value2">Das dritte zu suchende Zeichen.</param>
            <returns><c>true</c>, wenn eines der zu suchenden Zeichen in der Spanne gefunden wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Für den Vergleich wird MemoryExtensions.IndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, T, T, T) verwendet.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.ContainsNewLine(System.ReadOnlySpan{System.Char})">
            <summary>
            Gibt an, ob die schreibgeschütze Zeichenspanne ein Zeilenwechselzeichen enthält.
            </summary>
            <param name="span">Die zu durchsuchende Spanne.</param>
            <returns><c>true</c>, wenn <paramref name="span"/> ein Zeilenwechselzeichen enthält, andernfalls <c>false</c>.</returns>
            <remarks>Für den Vergleich wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/> verwendet.</remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.ContainsWhiteSpace(System.ReadOnlySpan{System.Char})">
            <summary>
            Gibt an, ob die schreibgeschütze Zeichenspanne ein Leerraumzeichen enthält.
            </summary>
            <param name="span">Die zu durchsuchende Spanne.</param>
            <returns><c>true</c>, wenn <paramref name="span"/> ein Leerraumzeichen enthält, andernfalls <c>false</c>.</returns>
            <remarks>Für den Vergleich wird <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> verwendet.</remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.EndsWith(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Gibt an, ob eine schreibgeschützte Zeichenspanne mit dem angegebenen
            Unicode-Zeichen endet.
            </summary>
            <param name="span">Die zu untersuchende Spanne.</param>
            <param name="value">Das Zeichen, nach dem gesucht wird.</param>
            <returns><c>true</c>, wenn <paramref name="span"/> mit <paramref name="value"/>
            endet, andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.GetPersistentHashCode(System.ReadOnlySpan{System.Char},FolkerKinzel.Strings.HashType)">
            <summary>
            Erzeugt bei jedem Programmlauf denselben <see cref="T:System.Int32"/>-Hashcode für eine identische Zeichenfolge.
            </summary>
            <param name="span">Die zu hashende Zeichenfolge.</param>
            <param name="hashType">Die Art des zu erzeugenden Hashcodes.</param>
            <returns>Der Hashcode.</returns>
            <remarks>
            <para>
            Die Methode <see cref="M:System.String.GetHashCode">String.GetHashCode()</see> gibt aus Sicherheitsgründen bei jedem Programmlauf 
            einen unterschiedlichen
            Hashcode für eine identische Zeichenfolge zurück. Abgesehen davon, dass auch der Hash-Algorithmus von 
            <see cref="M:System.String.GetHashCode">String.GetHashCode()</see> in unterschiedlichen Frameworkversionen unterschiedlich sein könnte, 
            macht es schon deshalb keinen
            Sinn, den Rückgabewert von <see cref="M:System.String.GetHashCode"/> für die Wiederverwendung zu speichern. Die Alternativen, z.B.
            <see cref="T:System.Security.Cryptography.MD5"/> oder <see cref="T:System.Security.Cryptography.SHA256"/>, verbrauchen mehr Speicherplatz und sind langsamer. So bietet diese Methode eine
            schlanke Alternative, die sich zum Hashen sehr kurzer Zeichenfolgen eignet, die nicht in einem sicherheitskritischen Zusammenhang 
            verwendet werden.
            </para>
            <para>
            Der von dieser Methode erzeugte Hashcode ist nicht identisch mit dem Hashcode, der von .NET-Framework 4.0
            erzeugt wird, denn 
            er verwendet Roundshifting, um mehr Information zu bewahren. 
            </para>
            <para>Die mit unterschiedlichen Werten für <paramref name="hashType"/> erzeugten Hashcodes können
            für eine identische Zeichenfolge verschiedene Hashcodes liefern und dürfen deshalb nicht vermischt werden.</para>
            <para>
            Verwenden Sie die von der Methode erzeugten Hashcodes nicht in 
            sicherheitskritischen Anwendungen (wie z.B. dem Hashen von Passwörtern)!
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="hashType"/> ist kein 
            definierter Wert der <see cref="T:FolkerKinzel.Strings.HashType"/>-Enum.</exception>
            <example>
            <code language="cs" source="..\Examples\Example.cs"/>
            </example>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.GetTrimmedLength(System.ReadOnlySpan{System.Char})">
            <summary>
            Gibt die Länge zurück, die die schreibgeschützte Zeichenspanne ohne nachgestellten Leerraum hätte.
            </summary>
            <param name="span">Die zu untersuchende Zeichenspanne.</param>
            <returns>Die Länge, die <paramref name="span"/> ohne nachgestellten Leerraum hätte.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.GetTrimmedStart(System.ReadOnlySpan{System.Char})">
            <summary>
            Gibt den Index des ersten Nicht-Leerraumzeichens in der schreibgeschützten Zeichenspanne zurück.
            </summary>
            <param name="span">Die zu untersuchende Zeichenspanne.</param>
            <returns>Der Index des ersten Nicht-Leerraumzeichens in der schreibgeschützten Zeichenspanne.
            Wenn die Spanne leer ist oder nur aus Leerraum besteht, entspricht der Rückgabewert der Länge
            der Spanne.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.IndexOfAny(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Sucht nach dem NULL-basierten Index des ersten Vorkommens eines der angegebenen Unicode-Zeichen.
            </summary>
            <param name="span">Die zu untersuchende Spanne.</param>
            <param name="values">Eine schreibgeschützte Zeichenspanne, die die zu suchenden Zeichen enthält.</param>
            <returns>Der NULL-basierte Index des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="values"/>
            in <paramref name="span"/> oder -1, wenn keines der Zeichen gefunden wurde. Wenn <paramref name="values"/> eine 
            leere Spanne ist, gibt die Methode -1 zurück.</returns>
            <remarks>
            <para>
            Diese Spezialisierung der Erweiterungsmethode MemoryExtensions.IndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, ReadOnlySpan&lt;T&gt;)
            für den Datentyp <see cref="T:System.Char"/> wird benötigt, um Performanceprobleme zu vermeiden.
            </para>
            <para>
            Wenn die Länge von <paramref name="values"/> kleiner als 5 ist, verwendet die Methode für den Vergleich 
            MemoryExtensions.IndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, ReadOnlySpan&lt;T&gt;). Ist die Länge von <paramref name="values"/>
            größer, wird <see cref="M:System.String.IndexOfAny(System.Char[])"/> verwendet.
            </para>
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.IsAscii(System.ReadOnlySpan{System.Char})">
            <summary>
            Untersucht, ob die schreibgeschützte Zeichenspanne Unicode-Zeichen enthält,
            die nicht zum ASCII-Zeichensatz gehören.
            </summary>
            <param name="span">Eine schreibgeschützte Spanne von Unicode-Zeichen.</param>
            <returns><c>false</c>, wenn <paramref name="span"/> ein Unicode-Zeichen enthält, das nicht zum 
            ASCII-Zeichensatz gehört, andernfalls <c>true</c>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.LastIndexOf(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Gibt die NULL-basierte Indexposition des letzten Vorkommens einer angegebenen Zeichenfolge in <paramref name="span"/> an. Die Suche beginnt an einer angegebenen Zeichenposition 
            und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenspanne. Ein Parameter gibt den Typ des bei der Suche nach der angegebenen 
            Zeichenfolge auszuführenden Vergleichs an.
            </summary>
            <param name="span">Die zu durchsuchende Zeichenspanne.</param>
            <param name="value">Die zu suchende Zeichenspanne.</param>
            <param name="startIndex">Die Anfangsposition der Suche. Die Suche wird von <paramref name="startIndex"/> bis zum Anfang von <paramref name="span"/> fortgesetzt.</param>
            <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
            <param name="comparisonType">Einer der Enumerationswerte, der die Regeln für die Suche angibt.</param>
            <returns>Die nullbasierte Anfangsindexposition des <paramref name="value"/>-Parameters, wenn diese Zeichenfolge gefunden wurde, oder -1, wenn sie nicht 
            gefunden wurde oder <paramref name="span"/> leer ist.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="count"/> ist ein negativer Wert
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="span"/> ist nicht <see cref="P:System.ReadOnlySpan`1.Empty"/>, und <paramref name="startIndex"/> ist ein negativer Wert.
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="span"/> ist nicht <see cref="P:System.ReadOnlySpan`1.Empty"/>, und <paramref name="startIndex"/> ist größer als die Länge von <paramref name="span"/>.
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="span"/> ist nicht <see cref="P:System.ReadOnlySpan`1.Empty"/>, und <paramref name="startIndex"/> + 1 - <paramref name="count"/> gibt eine Position an, 
            die nicht innerhalb von <paramref name="span"/> liegt.
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="span"/> ist <see cref="P:System.ReadOnlySpan`1.Empty"/>, und <paramref name="startIndex"/> ist kleiner als -1 oder größer als 0.
            </para>
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="comparisonType"/> ist kein gültiger <see cref="T:System.StringComparison"/>-Wert.
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.LastIndexOfAny(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Sucht nach dem NULL-basierten Index des letzten Vorkommens eines der angegebenen Unicode-Zeichen.
            </summary>
            <param name="span">Die zu untersuchende Spanne.</param>
            <param name="values">Eine schreibgeschützte Zeichenspanne, die die zu suchenden Zeichen enthält.</param>
            <returns>Der NULL-basierte Index des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="values"/>
            in <paramref name="span"/> oder -1, wenn keines der Zeichen gefunden wurde. Wenn <paramref name="values"/> eine
            leere Spanne ist, wird -1 zurückgegeben</returns>
            <remarks>
            <para>
            Diese Spezialisierung der Erweiterungsmethode MemoryExtensions.LastIndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, ReadOnlySpan&lt;T&gt;)
            für den Datentyp <see cref="T:System.Char"/> wird benötigt, um Performanceprobleme zu vermeiden.
            </para>
            <para>
            Wenn die Länge von <paramref name="values"/> kleiner als 5 ist, verwendet die Methode für den Vergleich 
            MemoryExtensions.LastIndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, ReadOnlySpan&lt;T&gt;).
            Ist die Länge von <paramref name="values"/>
            größer, wird <see cref="M:System.String.LastIndexOfAny(System.Char[])"/> verwendet.
            </para>
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.LastIndexOfAny(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Int32,System.Int32)">
            <summary>
            Gibt die nullbasierte Indexposition des letzten Vorkommens eines der angegebenen Zeichen 
            in <paramref name="span"/> an. Die Suche beginnt an einer angegebenen Zeichenposition 
            und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.
            </summary>
            <param name="span">Die zu durchsuchende schreibgeschützte Zeichenspanne.</param>
            <param name="values">Eine schreibgeschützte Zeichenspanne, die die zu suchenden Zeichen enthält.</param>
            <param name="startIndex">Die Anfangsposition der Suche. Die Suche erfolgt rückwärts zum Anfang 
            von <paramref name="span"/>.</param>
            <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen in <paramref name="span"/>.</param>
            <returns>Der nullbasierte Index des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="values"/>
            in <paramref name="span"/> oder -1, wenn keines dieser Zeichen gefunden wurde.</returns>
            <remarks>
            Wenn die Länge von <paramref name="values"/> kleiner als 5 ist, verwendet die Methode für den Vergleich 
            <see cref="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})"/>. Ist die Länge von <paramref name="values"/>
            größer, wird <see cref="M:System.String.LastIndexOfAny(System.Char[])"/> verwendet.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="span"/> ist nicht <see cref="P:System.ReadOnlySpan`1.Empty"/> und <paramref name="startIndex"/> ist 
            kleiner als 0 oder größer oder gleich der Länge von <paramref name="span"/>
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="span"/> ist nicht <see cref="P:System.ReadOnlySpan`1.Empty"/> und <paramref name="startIndex"/> - <paramref name="count"/> + 1 
            ist kleiner als 0.
            </para>
            </exception>
            
        </member>
        <member name="M:FolkerKinzel.Strings.ReadOnlySpanExtension.StartsWith(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Gibt an, ob eine schreibgeschützte Zeichenspanne mit dem angegebenen
            Unicode-Zeichen beginnt.
            </summary>
            <param name="span">Die zu untersuchende Spanne.</param>
            <param name="value">Das Zeichen, nach dem gesucht wird.</param>
            <returns><c>true</c>, wenn <paramref name="span"/> mit <paramref name="value"/>
            beginnt, andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
        </member>
        <member name="T:FolkerKinzel.Strings.StaticStringMethod">
            <summary>
            Simuliert statische Methoden der <see cref="T:System.String"/>-Klasse für .NET-Versionen, in denen diese nicht verfügbar sind, und leitet die Methodenaufrufe
            in .NET-Versionen, in denen die Methoden verfügbar sind, an die BCL-Methoden weiter.
            </summary>
        </member>
        <member name="M:FolkerKinzel.Strings.StaticStringMethod.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})">
            <summary>
            Erstellt eine neue Zeichenfolge mit einer bestimmten Länge und initialisiert sie nach der Erstellung unter Verwendung des angegebenen Rückrufs.
            </summary>
            <typeparam name="TState">Der Typ des Elements, das an <paramref name="action"/> übergeben werden soll.</typeparam>
            <param name="length">Die Länge des zu erstellenden <see cref="T:System.String"/>s.</param>
            <param name="state">Das an <paramref name="action"/> zu übergebende Element.</param>
            <param name="action">Ein Rückruf zum Initialisieren der Zeichenfolge.</param>
            <returns>Der erstellte <see cref="T:System.String"/>.</returns>
            <remarks>Die Methode simuliert die statische Methode String.Create&lt;TState&gt;(int, TState, SpanAction&lt;char,TState&gt;).
            In neueren .NET-Versionen wird der Aufruf direkt an die vorhandene Methode der <see cref="T:System.String"/>-Klasse weitergeleitet. In 
            .NET Framework und .NET Standard 2.0 ermöglicht die Simulation zumindest bei der Erstellung kurzer <see cref="T:System.String"/>s, mit 
            nur einer Heap-Allokation auszukommen.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="action"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> ist negativ.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StaticStringMethod.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Verkettet die Zeichenfolgendarstellung von vier angegebenen schreibgeschützten Zeichenspannen.
            </summary>
            <param name="str0">Die erste zu verkettende schreibgeschützte Zeichenspanne.</param>
            <param name="str1">Die zweite zu verkettende schreibgeschützte Zeichenspanne.</param>
            <param name="str2">Die dritte zu verkettende schreibgeschützte Zeichenspanne.</param>
            <param name="str3">Die vierte zu verkettende schreibgeschützte Zeichenspanne.</param>
            <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="str0"/>, 
            <paramref name="str1"/>, <paramref name="str2"/> und <paramref name="str3"/>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.StaticStringMethod.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Verkettet die Zeichenfolgendarstellung von drei angegebenen schreibgeschützten Zeichenspannen.
            </summary>
            <param name="str0">Die erste zu verkettende schreibgeschützte Zeichenspanne.</param>
            <param name="str1">Die zweite zu verkettende schreibgeschützte Zeichenspanne.</param>
            <param name="str2">Die dritte zu verkettende schreibgeschützte Zeichenspanne.</param>
            <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="str0"/>, 
            <paramref name="str1"/> und <paramref name="str2"/>.</returns>
        </member>
        <member name="M:FolkerKinzel.Strings.StaticStringMethod.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Verkettet die Zeichenfolgendarstellung von zwei angegebenen schreibgeschützten Zeichenspannen.
            </summary>
            <param name="str0">Die erste zu verkettende schreibgeschützte Zeichenspanne.</param>
            <param name="str1">Die zweite zu verkettende schreibgeschützte Zeichenspanne.</param>
            <returns>Die verketteten Zeichenfolgendarstellungen der Werte von <paramref name="str0"/> und
            <paramref name="str1"/>.</returns>
        </member>
        <member name="T:FolkerKinzel.Strings.StreamExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.IO.Stream"/>-Klasse.
            </summary>
        </member>
        <member name="M:FolkerKinzel.Strings.StreamExtension.IsUtf8(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
            Testet, ob der angegebene Abschnitt von <paramref name="stream"/>, der sich von der aktuellen <see cref="P:System.IO.Stream.Position"/>
            über mindestens <paramref name="count"/> Zeichen erstreckt, UTF-8-Text ist. Die Methode bezieht das Byte-Order-Mark (BOM)
            in die Prüfung ein.
            </summary>
            <param name="stream">Der zu testende <see cref="T:System.IO.Stream"/>.</param>
            <param name="count">Die Anzahl der mindestens zu überprüfenden Buchstaben. Wenn dem Parameter eine negative Zahl übergeben 
            wird oder wenn <paramref name="count"/> größer ist als die
            Länge der Daten in <paramref name="stream"/>, wird <paramref name="stream"/> von der aktuellen <see cref="P:System.IO.Stream.Position"/> 
            bis zu seinem Ende (EOF) überprüft. Wird dem Parameter <c>0</c> übergeben, überprüft die Methode nur das Byte-Order-Mark (BOM).</param>
            <param name="leaveOpen"><c>false</c>, damit die Methode <paramref name="stream"/> schließt, andernfalls <c>true</c>.</param>
            <returns><c>true</c>, wenn der in <paramref name="stream"/> überprüfte Abschnitt UTF-8-Text darstellt, andernfalls <c>false</c>.
            Wenn die Methode ein UTF-8-BOM findet, wird in jedem Fall <c>true</c> zurückgegeben. Wenn <paramref name="count"/>&#160;<c>0</c> ist 
            und kein UTF-8-BOM gefunden wird, wird <c>false</c> zurückgegeben.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> ist <c>null</c>.</exception>
            <exception cref="T:System.IO.IOException">E/A Fehler.</exception>
            <exception cref="T:System.ObjectDisposedException"><paramref name="stream"/> war bereits geschlossen.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="stream"/> unterstützt keine Lesevorgänge oder keinen wahlfreien Zugriff.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StreamExtension.IsUtf8Valid(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
            Testet, ob der angegebene Abschnitt von <paramref name="stream"/>, der sich von der aktuellen <see cref="P:System.IO.Stream.Position"/>
            über mindestens <paramref name="count"/> Zeichen erstreckt, gültiges UTF-8 darstellt.
            </summary>
            <param name="stream">Der zu testende <see cref="T:System.IO.Stream"/>.</param>
            <param name="count">Die Anzahl der mindestens zu überprüfenden Buchstaben. Wenn dem Parameter eine negative Zahl übergeben 
            wird (Default) oder wenn <paramref name="count"/> größer ist als die
            Länge der Daten in <paramref name="stream"/>, wird <paramref name="stream"/> von der aktuellen <see cref="P:System.IO.Stream.Position"/> 
            bis zu seinem Ende (EOF) überprüft. Der Wert <c>0</c> ist nicht erlaubt.</param>
            <param name="leaveOpen"><c>false</c>, damit die Methode <paramref name="stream"/> schließt, andernfalls <c>true</c>.</param>
            <returns><c>true</c>, wenn der in <paramref name="stream"/> überprüfte Abschnitt gültiges UTF-8 darstellt, andernfalls <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> ist <c>0</c>.</exception>
            <exception cref="T:System.IO.IOException">E/A Fehler.</exception>
            <exception cref="T:System.ObjectDisposedException"><paramref name="stream"/> war bereits geschlossen.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="stream"/> unterstützt keine Lesevorgänge.</exception>
        </member>
        <member name="T:FolkerKinzel.Strings.StringBuilderExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.Text.StringBuilder"/>-Klasse.
            </summary>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.AppendLine(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})">
            <summary>
            Fügt eine Kopie der angegebenen schreibgeschützten Zeichenspanne gefolgt vom Standardzeilenabschlusszeichen 
            am Ende eines <see cref="T:System.Text.StringBuilder"/>-Objekts an.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, an den Zeichen angefügt werden.</param>
            <param name="value">Die anzufügende schreibgeschützte Zeichenspanne.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Bei der Erhöhung der Kapazität von <paramref name="builder"/>
            würde <see cref="P:System.Text.StringBuilder.MaxCapacity"/> überschritten.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.AppendLine(System.Text.StringBuilder,System.ReadOnlyMemory{System.Char})">
            <summary>
            Fügt eine Kopie des angegebenen schreibgeschützten Zeichenspeichers gefolgt vom Standardzeilenabschlusszeichen 
            am Ende eines <see cref="T:System.Text.StringBuilder"/>-Objekts an.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, an den Zeichen angefügt werden.</param>
            <param name="value">Der anzufügende schreibgeschützte Zeichenspeicher.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>, nachdem der Anfügevorgang abgeschlossen wurde.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Bei der Erhöhung der Kapazität von <paramref name="builder"/>
            würde <see cref="P:System.Text.StringBuilder.MaxCapacity"/> überschritten.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.Contains(System.Text.StringBuilder,System.Char)">
            <summary>
            Gibt an, ob ein angegebenes Zeichen im <see cref="T:System.Text.StringBuilder"/> vorkommt.
            </summary>
            <param name="builder">Der zu durchsuchende <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">Das zu suchende Zeichen.</param>
            <returns><c>true</c>, wenn <paramref name="value"/> in <paramref name="builder"/>
            gefunden wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ContainsNewLine(System.Text.StringBuilder)">
            <summary>
            Untersucht, ob der <see cref="T:System.Text.StringBuilder"/> Zeilenwechselzeichen enthält.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt untersucht wird.</param>
            <returns><c>true</c>, wenn <paramref name="builder"/> Zeilenwechselzeichen enthält, andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode verwendet <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/> zur Identifizierung von Zeilenwechselzeichen.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ContainsNewLine(System.Text.StringBuilder,System.Int32)">
            <summary>
            Untersucht einen Abschnitt des <see cref="T:System.Text.StringBuilder"/>s, der bei <paramref name="startIndex"/> beginnt,
            daraufhin, ob er Zeilenwechselzeichen enthält.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt untersucht wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Untersuchung
            beginnt.</param>
            <returns><c>true</c>, wenn der Abschnitt in <paramref name="builder"/> Zeilenwechselzeichen enthält, 
            andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode verwendet <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/> zur Identifizierung von Zeilenwechselzeichen.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> ist kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ContainsNewLine(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Untersucht einen Abschnitt des <see cref="T:System.Text.StringBuilder"/>s, der bei <paramref name="startIndex"/> beginnt und
            <paramref name="count"/> Zeichen umfasst, daraufhin, ob dieser Abschnitt Zeilenwechselzeichen enthält.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt untersucht wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Untersuchung
            beginnt.</param>
            <param name="count">Die Länge des zu untersuchenden Abschnitts.</param>
            <returns><c>true</c>, wenn der Abschnitt in <paramref name="builder"/> Zeilenwechselzeichen enthält,
            andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode verwendet <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/> zur Identifizierung von Zeilenwechselzeichen.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/> sind kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>.
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="startIndex"/> + <paramref name="count"/> ist größer als die Anzahl der Zeichen in
            <paramref name="builder"/>.
            </para></exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ContainsNonAscii(System.Text.StringBuilder)">
            <summary>
            Untersucht, ob der <see cref="T:System.Text.StringBuilder"/> Unicode-Zeichen enthält,
            die nicht zum ASCII-Zeichensatz gehören.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt untersucht wird.</param>
            <returns><c>true</c>, wenn <paramref name="builder"/> ein Unicode-Zeichen enthält, das nicht zum 
            ASCII-Zeichensatz gehört, andernfalls <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ContainsNonAscii(System.Text.StringBuilder,System.Int32)">
            <summary>
            Untersucht einen Abschnitt des <see cref="T:System.Text.StringBuilder"/>s, der bei <paramref name="startIndex"/> beginnt,
            daraufhin, ob er Unicode-Zeichen enthält,
            die nicht zum ASCII-Zeichensatz gehören.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt untersucht wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Untersuchung
            beginnt.</param>
            <returns><c>true</c>, wenn der Abschnitt in <paramref name="builder"/> ein Unicode-Zeichen enthält, das nicht zum 
            ASCII-Zeichensatz gehört, andernfalls <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> ist kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ContainsNonAscii(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Untersucht einen Abschnitt des <see cref="T:System.Text.StringBuilder"/>s, der bei <paramref name="startIndex"/> beginnt und
            <paramref name="count"/> Zeichen umfasst, daraufhin, ob dieser Abschnitt Unicode-Zeichen enthält,
            die nicht zum ASCII-Zeichensatz gehören.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt untersucht wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Untersuchung
            beginnt.</param>
            <param name="count">Die Länge des zu untersuchenden Abschnitts.</param>
            <returns><c>true</c>, wenn der Abschnitt in <paramref name="builder"/> ein Unicode-Zeichen enthält, das nicht zum 
            ASCII-Zeichensatz gehört, andernfalls <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/> sind kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>.
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="startIndex"/> + <paramref name="count"/> ist größer als die Anzahl der Zeichen in
            <paramref name="builder"/>.
            </para></exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ContainsWhiteSpace(System.Text.StringBuilder)">
            <summary>
            Untersucht, ob der <see cref="T:System.Text.StringBuilder"/> Leerraumzeichen enthält.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt untersucht wird.</param>
            <returns><c>true</c>, wenn <paramref name="builder"/> Leerraumzeichen enthält, andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ContainsWhiteSpace(System.Text.StringBuilder,System.Int32)">
            <summary>
            Untersucht einen Abschnitt des <see cref="T:System.Text.StringBuilder"/>s, der bei <paramref name="startIndex"/> beginnt,
            daraufhin, ob er Leerraumzeichen enthält.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt untersucht wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Untersuchung
            beginnt.</param>
            <returns><c>true</c>, wenn der Abschnitt in <paramref name="builder"/> Leerraumzeichen enthält, 
            andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> ist kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ContainsWhiteSpace(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Untersucht einen Abschnitt des <see cref="T:System.Text.StringBuilder"/>s, der bei <paramref name="startIndex"/> beginnt und
            <paramref name="count"/> Zeichen umfasst, daraufhin, ob dieser Abschnitt Leerraumzeichen enthält.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt untersucht wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Untersuchung
            beginnt.</param>
            <param name="count">Die Länge des zu untersuchenden Abschnitts.</param>
            <returns><c>true</c>, wenn der Abschnitt in <paramref name="builder"/> Leerraumzeichen enthält,
            andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/> sind kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>.
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="startIndex"/> + <paramref name="count"/> ist größer als die Anzahl der Zeichen in
            <paramref name="builder"/>.
            </para></exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.EndsWith(System.Text.StringBuilder,System.Char)">
            <summary>
            Gibt an, ob der Inhalt eines <see cref="T:System.Text.StringBuilder"/>s mit dem angegebenen
            Unicode-Zeichen endet.
            </summary>
            <param name="builder">Der zu untersuchende <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">Das Zeichen, nach dem gesucht wird.</param>
            <returns><c>true</c>, wenn <paramref name="builder"/> mit <paramref name="value"/>
            endet, andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.GetPersistentHashCode(System.Text.StringBuilder,FolkerKinzel.Strings.HashType)">
            <summary>
            Erzeugt bei jedem Programmlauf denselben <see cref="T:System.Int32"/>-Hashcode für eine identische Zeichenfolge.
            </summary>
            <param name="builder">Die zu hashende Zeichenfolge.</param>
            <param name="hashType">Die Art des zu erzeugenden Hashcodes.</param>
            <returns>Der Hashcode.</returns>
            <remarks>
            <para>
            Die Methode <see cref="M:System.String.GetHashCode">String.GetHashCode()</see> gibt aus Sicherheitsgründen bei jedem Programmlauf 
            einen unterschiedlichen
            Hashcode für eine identische Zeichenfolge zurück. Abgesehen davon, dass auch der Hash-Algorithmus von 
            <see cref="M:System.String.GetHashCode">String.GetHashCode()</see> in unterschiedlichen Frameworkversionen unterschiedlich sein könnte, 
            macht es schon deshalb keinen
            Sinn, den Rückgabewert von <see cref="M:System.String.GetHashCode"/> für die Wiederverwendung zu speichern. Die Alternativen, z.B.
            <see cref="T:System.Security.Cryptography.MD5"/> oder <see cref="T:System.Security.Cryptography.SHA256"/>, verbrauchen mehr Speicherplatz und sind langsamer. So bietet diese Methode eine
            schlanke Alternative, die sich zum Hashen sehr kurzer Zeichenfolgen eignet, die nicht in einem sicherheitskritischen Zusammenhang 
            verwendet werden.
            </para>
            <para>
            Der von dieser Methode erzeugte Hashcode ist nicht identisch mit dem Hashcode, der von .NET-Framework 4.0
            erzeugt wird, denn 
            er verwendet Roundshifting, um mehr Information zu bewahren. 
            </para>
            <para>Die mit unterschiedlichen Werten für <paramref name="hashType"/> erzeugten Hashcodes können
            für eine identische Zeichenfolge verschiedene Hashcodes liefern und dürfen deshalb nicht vermischt werden.</para>
            <para>
            Verwenden Sie die von der Methode erzeugten Hashcodes nicht in 
            sicherheitskritischen Anwendungen (wie z.B. dem Hashen von Passwörtern)!
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="hashType"/> ist kein 
            definierter Wert der <see cref="T:FolkerKinzel.Strings.HashType"/>-Enum.</exception>
            <example>
            <code language="cs" source="..\Examples\Example.cs"/>
            </example>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.IndexOf(System.Text.StringBuilder,System.Char)">
            <summary>
            Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Zeichens in <paramref name="builder"/> an.
            </summary>
            <param name="builder">Der zu durchsuchende <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">Das zu suchende Unicode-Zeichen.</param>
            <returns>Die nullbasierte Indexposition von <paramref name="value"/> ab dem Anfang des <see cref="T:System.Text.StringBuilder"/>s,
            wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.IndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>
            Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Zeichens in <paramref name="builder"/> an. 
            Die Suche beginnt an der angegebenen Zeichenposition.
            </summary>
            <param name="builder">Der zu durchsuchende <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">Das zu suchende Unicode-Zeichen.</param>
            <param name="startIndex">Die Anfangsposition der Suche.</param>
            <returns>Die nullbasierte Indexposition von <paramref name="value"/> ab dem Anfang des <see cref="T:System.Text.StringBuilder"/>s,
            wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> ist kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.IndexOf(System.Text.StringBuilder,System.Char,System.Int32,System.Int32)">
            <summary>
            Gibt den NULL-basierten Index des ersten Vorkommens des angegebenen Zeichens in <paramref name="builder"/> an. 
            Die Suche beginnt an einer angegebenen Zeichenposition, und es wird eine angegebene Anzahl 
            von Zeichenpositionen überprüft.
            </summary>
            <param name="builder">Der zu durchsuchende <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">Das zu suchende Unicode-Zeichen.</param>
            <param name="startIndex">Die Anfangsposition der Suche.</param>
            <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
            <returns>Die nullbasierte Indexposition von <paramref name="value"/> ab dem Anfang des <see cref="T:System.Text.StringBuilder"/>s,
            wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/> sind kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="startIndex"/> + <paramref name="count"/> ist größer als die Anzahl der Zeichen in
            <paramref name="builder"/>.
            </para></exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.LastIndexOf(System.Text.StringBuilder,System.Char)">
            <summary>
            Gibt den NULL-basierten Index des letzten Vorkommens des angegebenen Zeichens in <paramref name="builder"/> an.
            </summary>
            <param name="builder">Der zu durchsuchende <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">Das zu suchende Unicode-Zeichen.</param>
            <returns>Die nullbasierte Indexposition des letzten Vorkommens von <paramref name="value"/>,
            wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.LastIndexOf(System.Text.StringBuilder,System.Char,System.Int32)">
            <summary>
            Gibt den NULL-basierten Index des letzten Vorkommens des angegebenen Zeichens in <paramref name="builder"/> an. 
            Die Suche beginnt an einer angegebenen Zeichenposition und verläuft
            rückwärts zum Anfang des <see cref="T:System.Text.StringBuilder"/>s.
            </summary>
            <param name="builder">Der zu durchsuchende <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">Das zu suchende Unicode-Zeichen.</param>
            <param name="startIndex">Die Anfangsposition der Suche. Die Suche erfolgt rückwärts zum Anfang 
            von <paramref name="builder"/>.</param>
            <returns>Die nullbasierte Indexposition des letzten Vorkommens von <paramref name="value"/>,
            wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="builder"/> ist nicht leer und 
            <paramref name="startIndex"/> ist kleiner als 0 oder größer 
            oder gleich der Länge von <paramref name="builder"/>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.LastIndexOf(System.Text.StringBuilder,System.Char,System.Int32,System.Int32)">
            <summary>
            Gibt den NULL-basierten Index des letzten Vorkommens des angegebenen Zeichens in <paramref name="builder"/> an. 
            Die Suche beginnt an einer angegebenen Zeichenposition und verläuft für eine angegebene Anzahl von Zeichenpositionen 
            rückwärts zum Anfang des <see cref="T:System.Text.StringBuilder"/>s.
            </summary>
            <param name="builder">Der zu durchsuchende <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">Das zu suchende Unicode-Zeichen.</param>
            <param name="startIndex">Die Anfangsposition der Suche. Die Suche erfolgt rückwärts zum Anfang 
            von <paramref name="builder"/>.</param>
            <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
            <returns>Die nullbasierte Indexposition des letzten Vorkommens von <paramref name="value"/>,
            innerhalb des zu durchsuchenden Abschnitts wenn dieses Zeichen gefunden wurde, andernfalls -1.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="builder"/> ist nicht leer und <paramref name="startIndex"/> ist kleiner als 0 oder größer 
            oder gleich der Länge von <paramref name="builder"/>
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="builder"/> ist nicht leer und <paramref name="startIndex"/> - <paramref name="count"/> + 1 
            ist kleiner als 0.
            </para></exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.NormalizeNewLinesTo(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})">
            <summary>
            Ersetzt alle Zeilenumbrüche in <paramref name="builder"/> durch <paramref name="newLine"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="newLine">Eine schreibgeschützte Zeichenspanne, durch deren Inhalt jeder Zeilenumbruch
            ersetzt wird. Wenn eine leere Spanne übergeben wird, werden alle Zeilenumbrüche entfernt.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <remarks>
            <para>
            Für die Identifizierung von Zeilenwechselzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/> 
            verwendet. Die Sequenzen CRLF und LFCR werden als ein Zeilenumbruch behandelt.
            </para>
            <note type="caution">
            Diese Methode unterscheidet sich von <see cref="M:FolkerKinzel.Strings.StringBuilderExtension.ReplaceLineEndings(System.Text.StringBuilder,System.String)"/> dahingehend,
            dass sie zusätzlich LFCR-Sequenzen und Vertical Tab (VT: U+000B) als Zeilenwechsel behandelt.
            </note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ReplaceLineEndings(System.Text.StringBuilder,System.String)">
            <summary>
            Ersetzt alle Newlinesequenzen in <paramref name="builder"/> durch <paramref name="replacementText"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="replacementText">Der Text, der als Ersatz verwendet werden soll. Wenn <paramref name="replacementText"/>&#160;
            <c>null</c> oder <see cref="F:System.String.Empty"/> ist, werden alle Newlinesequenzen in <paramref name="builder"/> entfernt.</param>
            <returns>Eine Referenz auf <paramref name="builder"/>.</returns>
            <remarks>
            <para>
            Die Liste der behandelten Newlinesequenzen ist:
            </para>
            <list type="bullet">
            <item>CR (U+000D)</item>
            <item>LF (U+000A)</item>
            <item>CRLF (U+000D U+000A)</item>
            <item>NEL (U+0085)</item>
            <item>LS (U+2028)</item>
            <item>FF (U+000C)</item>
            <item>PS (U+2029)</item>
            </list>
            <para>
            Diese Liste ist vom Unicode-Standard vorgegeben (Sec. 5.8, Recommendation R4 und Table 5-2).
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ReplaceWhiteSpaceWith(System.Text.StringBuilder,System.ReadOnlySpan{System.Char},System.Boolean)">
            <summary>
            Ersetzt in <paramref name="builder"/> alle Sequenzen von Leerzeichen durch <paramref name="replacement"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="replacement">Eine schreibgeschützte Zeichenspanne, durch deren Inhalt die Leerzeichen-Sequenzen
            ersetzt werden.</param>
            <param name="skipNewLines">Übergeben Sie <c>true</c>, um Zeilenumbruchzeichen von der 
            Ersetzung auszunehmen. Der Standardwert ist <c>false</c>.</param>
            <returns>Eine Referenz auf <paramref name="builder"/></returns>
            <remarks>
            <para>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen und arbeitet
            damit gründlicher als 
            <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">Regex.Replace(string input, @"\s+", string replacement)</see>.
            </para>
            <para>(Zur Identifizierung von Zeilenumbruchzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/>
            verwendet.)
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ReplaceWhiteSpaceWith(System.Text.StringBuilder,System.ReadOnlySpan{System.Char},System.Int32,System.Boolean)">
            <summary>
            Ersetzt in einem Abschnitt von <paramref name="builder"/>, der bei <paramref name="startIndex"/> beginnt
            und bis zum Ende von <paramref name="builder"/> reicht, alle Sequenzen von Leerzeichen durch <paramref name="replacement"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="replacement">Eine schreibgeschützte Zeichenspanne, durch deren Inhalt die Leerzeichen-Sequenzen
            ersetzt werden.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem der Abschnitt beginnt,
            in dem die Ersetzungen vorgenommen werden.</param>
            <param name="skipNewLines">Übergeben Sie <c>true</c>, um Zeilenumbruchzeichen von der 
            Ersetzung auszunehmen. Der Standardwert ist <c>false</c>.</param>
            <returns>Eine Referenz auf <paramref name="builder"/></returns>
            <remarks>
            <para>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen und arbeitet
            damit gründlicher als 
            <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">Regex.Replace(string input, @"\s+", string replacement)</see>.
            </para>
            <para>(Zur Identifizierung von Zeilenumbruchzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/>
            verwendet.)
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="startIndex"/> ist kleiner als 0 oder größer als die Anzahl der Zeichen in <paramref name="builder"/>.
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ReplaceWhiteSpaceWith(System.Text.StringBuilder,System.ReadOnlySpan{System.Char},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Ersetzt in einem Abschnitt von <paramref name="builder"/>, der bei <paramref name="startIndex"/> beginnt
            und <paramref name="count"/> Zeichen umfasst, alle Sequenzen von Leerzeichen durch <paramref name="replacement"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="replacement">Eine schreibgeschützte Zeichenspanne, durch deren Inhalt die Leerzeichen-Sequenzen
            ersetzt werden.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem der Abschnitt beginnt,
            in dem die Ersetzungen vorgenommen werden.</param>
            <param name="count">Die Länge des Abschnitts, in dem Ersetzungen vorgenommen werden.</param>
            <param name="skipNewLines">Übergeben Sie <c>true</c>, um Zeilenumbruchzeichen von der 
            Ersetzung auszunehmen. Der Standardwert ist <c>false</c>.</param>
            <returns>Eine Referenz auf <paramref name="builder"/></returns>
            <remarks>
            <para>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen und arbeitet
            damit gründlicher als 
            <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">Regex.Replace(string input, @"\s+", string replacement)</see>.
            </para>
            <para>(Zur Identifizierung von Zeilenumbruchzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/>
            verwendet.)
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/> ist kleiner als 0
            </para>
            <para>- oder -</para>
            <para>
            <paramref name="startIndex"/> + <paramref name="count"/>
            ist größer als die Anzahl der Zeichen in <paramref name="builder"/>.
            </para>
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.StartsWith(System.Text.StringBuilder,System.Char)">
            <summary>
            Gibt an, ob der Inhalt eines <see cref="T:System.Text.StringBuilder"/>s mit dem angegebenen
            Unicode-Zeichen beginnt.
            </summary>
            <param name="builder">Der zu untersuchende <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="value">Das Zeichen, nach dem gesucht wird.</param>
            <returns><c>true</c>, wenn <paramref name="builder"/> mit <paramref name="value"/>
            beginnt, andernfalls <c>false</c>.</returns>
            <remarks>
            Die Methode führt einen Ordinalzeichenvergleich durch.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ToLowerInvariant(System.Text.StringBuilder)">
            <summary>
            Wandelt den gesamten Inhalt eines <see cref="T:System.Text.StringBuilder"/>s in Kleinbuchstaben um und verwendet
            dabei die Regeln der invarianten Kultur.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <returns>Eine Referenz auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ToLowerInvariant(System.Text.StringBuilder,System.Int32)">
            <summary>
            Wandelt den Inhalt eines <see cref="T:System.Text.StringBuilder"/>s beginnend bei <paramref name="startIndex"/>
            in Kleinbuchstaben um und verwendet
            dabei die Regeln der invarianten Kultur.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Umwandlung
            beginnt.</param>
            <returns>Eine Referenz auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> ist kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ToLowerInvariant(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Wandelt den Inhalt eines Abschnitts in <see cref="T:System.Text.StringBuilder"/>, der bei <paramref name="startIndex"/>
            beginnt und <paramref name="count"/> Zeichen umfasst, in Kleinbuchstaben um und verwendet
            dabei die Regeln der invarianten Kultur.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Umwandlung
            beginnt.</param>
            <param name="count">Die Anzahl der zu bearbeitenden Zeichen.</param>
            <returns>Eine Referenz auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/> sind kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="startIndex"/> + <paramref name="count"/> ist größer als die Anzahl der Zeichen in
            <paramref name="builder"/>.
            </para></exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ToUpperInvariant(System.Text.StringBuilder)">
            <summary>
            Wandelt den gesamten Inhalt eines <see cref="T:System.Text.StringBuilder"/>s in Großbuchstaben um und verwendet
            dabei die Regeln der invarianten Kultur.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <returns>Eine Referenz auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ToUpperInvariant(System.Text.StringBuilder,System.Int32)">
            <summary>
            Wandelt den Inhalt eines <see cref="T:System.Text.StringBuilder"/>s beginnend bei <paramref name="startIndex"/>
            in Großbuchstaben um und verwendet
            dabei die Regeln der invarianten Kultur.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Umwandlung
            beginnt.</param>
            <returns>Eine Referenz auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> ist kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.ToUpperInvariant(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Wandelt den Inhalt eines Abschnitts in <see cref="T:System.Text.StringBuilder"/>, der bei <paramref name="startIndex"/>
            beginnt und <paramref name="count"/> Zeichen umfasst, in Großbuchstaben um und verwendet
            dabei die Regeln der invarianten Kultur.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt bearbeitet wird.</param>
            <param name="startIndex">Der nullbasierte Index in <paramref name="builder"/>, an dem die Umwandlung
            beginnt.</param>
            <param name="count">Die Anzahl der zu bearbeitenden Zeichen.</param>
            <returns>Eine Referenz auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/> sind kleiner als 0 oder
            größer als die Anzahl der Zeichen in <paramref name="builder"/>
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="startIndex"/> + <paramref name="count"/> ist größer als die Anzahl der Zeichen in
            <paramref name="builder"/>.
            </para></exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.Trim(System.Text.StringBuilder)">
            <summary>
            Entfernt alle führenden und nachgestellten Leerraumzeichen aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.Trim(System.Text.StringBuilder,System.Char)">
            <summary>
            Entfernt alle führenden und nachgestellten Instanzen eines Zeichens aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="trimChar">Ein zu entfernendes Unicode-Zeichen.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.Trim(System.Text.StringBuilder,System.Char[])">
            <summary>
            Entfernt alle führenden und nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <c>null</c>. Wenn <paramref name="trimChars"/>&#160;<c>null</c>
            oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.Trim(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})">
            <summary>
            Entfernt alle führenden und nachgestellten Vorkommen der Zeichen in der angegebenen Spanne aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="trimChars">Eine Spanne mit den zu entfernenden Unicode-Zeichen. Wenn <paramref name="trimChars"/> eine leere Spanne ist,
            werden stattdessen Leerzeichen entfernt.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.TrimEnd(System.Text.StringBuilder)">
            <summary>
            Entfernt alle nachgestellten Leerraumzeichen aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.TrimEnd(System.Text.StringBuilder,System.Char)">
            <summary>
            Entfernt alle nachgestellten Instanzen eines Zeichens aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="trimChar">Ein zu entfernendes Unicode-Zeichen.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.TrimEnd(System.Text.StringBuilder,System.Char[])">
            <summary>
            Entfernt alle nachgestellten Vorkommen der Zeichen im angegebenen Array aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <c>null</c>. Wenn 
            <paramref name="trimChars"/>&#160;<c>null</c>
            oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.TrimEnd(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})">
            <summary>
            Entfernt alle nachgestellten Vorkommen der Zeichen in der angegebenen Spanne aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="trimChars">Eine Spanne mit den zu entfernenden Unicode-Zeichen. Wenn 
            <paramref name="trimChars"/> eine leere Spanne ist, werden stattdessen Leerzeichen entfernt.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.TrimStart(System.Text.StringBuilder)">
            <summary>
            Entfernt alle führenden Leerraumzeichen aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.TrimStart(System.Text.StringBuilder,System.Char)">
            <summary>
            Entfernt alle führenden Instanzen eines Zeichens aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="trimChar">Ein zu entfernendes Unicode-Zeichen.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.TrimStart(System.Text.StringBuilder,System.Char[])">
            <summary>
            Entfernt alle führenden Vorkommen der Zeichen im angegebenen Array aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="trimChars">Ein Array mit den zu entfernenden Unicode-Zeichen oder <c>null</c>. Wenn 
            <paramref name="trimChars"/>&#160;<c>null</c>
            oder ein leeres Array ist, werden stattdessen Leerzeichen entfernt.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringBuilderExtension.TrimStart(System.Text.StringBuilder,System.ReadOnlySpan{System.Char})">
            <summary>
            Entfernt alle führenden Vorkommen der Zeichen in der angegebenen Spanne aus dem <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">Der <see cref="T:System.Text.StringBuilder"/>, dessen Inhalt verändert wird.</param>
            <param name="trimChars">Eine Spanne mit den zu entfernenden Unicode-Zeichen oder <c>null</c>. Wenn 
            <paramref name="trimChars"/> eine leere Spanne ist, werden stattdessen Leerzeichen entfernt.</param>
            <returns>Ein Verweis auf <paramref name="builder"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="builder"/> ist <c>null</c>.</exception>
        </member>
        <member name="T:FolkerKinzel.Strings.StringExtension">
            <summary>
            Erweiterungsmethoden für die <see cref="T:System.String"/>-Klasse.
            </summary>
            <threadsafety static="true" instance="false"/>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.ContainsAny(System.String,System.Char,System.Char)">
            <summary>
            Gibt an, ob in einem <see cref="T:System.String"/> eines der beiden Zeichen vorkommt,
            die der Methode als Argumente übergeben werden.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="value0">Das erste zu suchende Zeichen.</param>
            <param name="value1">Das zweite zu suchende Zeichen.</param>
            <returns><c>true</c>, wenn eines der zu suchenden Zeichen in <paramref name="s"/> gefunden wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Für den Vergleich wird MemoryExtensions.IndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, T, T) verwendet.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.ContainsAny(System.String,System.Char,System.Char,System.Char)">
            <summary>
            Gibt an, ob in einem <see cref="T:System.String"/> eines der drei Zeichen vorkommt,
            die der Methode als Argumente übergeben werden.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="value0">Das erste zu suchende Zeichen.</param>
            <param name="value1">Das zweite zu suchende Zeichen.</param>
            <param name="value2">Das dritte zu suchende Zeichen.</param>
            <returns><c>true</c>, wenn eines der zu suchenden Zeichen in <paramref name="s"/>
            gefunden wird, andernfalls <c>false</c>.</returns>
            <remarks>
            Für den Vergleich wird MemoryExtensions.IndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, T, T, T) verwendet.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.ContainsAny(System.String,System.ReadOnlySpan{System.Char})">
            <summary>
            Gibt an, ob in einem <see cref="T:System.String"/> eines der Zeichen vorkommt,
            die der Methode in einer schreibgeschützten Zeichenspanne übergeben werden.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="anyOf">Eine schreibgeschützte Zeichenspanne, die die zu suchenden Zeichen enthält.</param>
            <returns><c>true</c>, wenn eines der zu suchenden Zeichen in <paramref name="s"/> gefunden wird,
            andernfalls <c>false</c>. Wenn <paramref name="s"/> oder <paramref name="anyOf"/> die Länge 0 haben,
            wird <c>false</c> zurückgegeben.</returns>
            <remarks>
            Wenn die Länge von <paramref name="anyOf"/> kleiner als 5 ist, verwendet die Methode für den Vergleich 
            MemoryExtensions.IndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, ReadOnlySpan&lt;T&gt;). Ist die Länge von <paramref name="anyOf"/>
            größer, wird <see cref="M:System.String.IndexOfAny(System.Char[])"/> verwendet.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.ContainsAny(System.String,System.Char[])">
            <summary>
            Gibt an, ob in einem <see cref="T:System.String"/> eines der Zeichen vorkommt,
            die der Methode als Zeichenarray übergeben werden.
            </summary>
            <param name="s">Der zu untersuchende <see cref="T:System.String"/>.</param>
            <param name="anyOf">Ein Array, das die zu suchenden Zeichen enthält.</param>
            <returns><c>true</c>, wenn eines der zu suchenden Zeichen in <paramref name="s"/> gefunden wird, 
            andernfalls <c>false</c>. Wenn <paramref name="s"/> oder <paramref name="anyOf"/> die Länge 0 haben,
            wird <c>false</c> zurückgegeben.</returns>
            <remarks>Für den Vergleich wird <see cref="M:System.String.IndexOfAny(System.Char[])"/> verwendet.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> oder <paramref name="anyOf"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.ContainsNewLine(System.String)">
            <summary>
            Gibt an, ob der <see cref="T:System.String"/> ein Zeilenwechselzeichen enthält.
            </summary>
            <param name="s">Der zu durchsuchende <see cref="T:System.String"/>.</param>
            <returns><c>true</c>, wenn <paramref name="s"/> ein Leerraumzeichen enthält, andernfalls <c>false</c>.</returns>
            <remarks>Für den Vergleich wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/> verwendet.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.ContainsWhiteSpace(System.String)">
            <summary>
            Gibt an, ob der <see cref="T:System.String"/> ein Leerraumzeichen enthält.
            </summary>
            <param name="s">Der zu durchsuchende <see cref="T:System.String"/>.</param>
            <returns><c>true</c>, wenn <paramref name="s"/> ein Leerraumzeichen enthält, andernfalls <c>false</c>.</returns>
            <remarks>Für den Vergleich wird <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> verwendet.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.GetPersistentHashCode(System.String,FolkerKinzel.Strings.HashType)">
            <summary>
            Erzeugt bei jedem Programmlauf denselben <see cref="T:System.Int32"/>-Hashcode für eine identische Zeichenfolge.
            </summary>
            <param name="s">Die zu hashende Zeichenfolge.</param>
            <param name="hashType">Die Art des zu erzeugenden Hashcodes.</param>
            <returns>Der Hashcode.</returns>
            <remarks>
            <para>
            Die Methode <see cref="M:System.String.GetHashCode">String.GetHashCode()</see> gibt aus Sicherheitsgründen bei jedem Programmlauf 
            einen unterschiedlichen
            Hashcode für eine identische Zeichenfolge zurück. Abgesehen davon, dass auch der Hash-Algorithmus von 
            <see cref="M:System.String.GetHashCode">String.GetHashCode()</see> in unterschiedlichen Frameworkversionen unterschiedlich sein könnte, 
            macht es schon deshalb keinen
            Sinn, den Rückgabewert von <see cref="M:System.String.GetHashCode"/> für die Wiederverwendung zu speichern. Die Alternativen, z.B.
            <see cref="T:System.Security.Cryptography.MD5"/> oder <see cref="T:System.Security.Cryptography.SHA256"/>, verbrauchen mehr Speicherplatz und sind langsamer. So bietet diese Methode eine
            schlanke Alternative, die sich zum Hashen sehr kurzer Zeichenfolgen eignet, die nicht in einem sicherheitskritischen Zusammenhang 
            verwendet werden.
            </para>
            <para>
            Der von dieser Methode erzeugte Hashcode ist nicht identisch mit dem Hashcode, der von .NET-Framework 4.0
            erzeugt wird, denn 
            er verwendet Roundshifting, um mehr Information zu bewahren. 
            </para>
            <para>Die mit unterschiedlichen Werten für <paramref name="hashType"/> erzeugten Hashcodes können
            für eine identische Zeichenfolge verschiedene Hashcodes liefern und dürfen deshalb nicht vermischt werden.</para>
            <para>
            Verwenden Sie die von der Methode erzeugten Hashcodes nicht in 
            sicherheitskritischen Anwendungen (wie z.B. dem Hashen von Passwörtern)!
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="hashType"/> ist kein 
            definierter Wert der <see cref="T:FolkerKinzel.Strings.HashType"/>-Enum.</exception>
            <example>
            <code language="cs" source="..\Examples\Example.cs"/>
            </example>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.IndexOfAny(System.String,System.ReadOnlySpan{System.Char},System.Int32,System.Int32)">
            <summary>
            Sucht nach dem NULL-basierten Index des ersten Vorkommens eines beliebigen Zeichens aus einer
            schreibgeschützten Zeichenspanne in <paramref name="s"/>. Die Suche beginnt an einer angegebenen 
            Zeichenposition, und es wird eine angegebene Anzahl von Zeichenpositionen überprüft.
            </summary>
            <param name="s">Der zu durchsuchende <see cref="T:System.String"/>.</param>
            <param name="anyOf">Eine schreibgeschützte Zeichenspanne, die die zu suchenden Zeichen enthält.</param>
            <param name="startIndex">Der NULL-basierte Index in <paramref name="s"/>, an dem die Suche beginnt.</param>
            <param name="count">Die Anzahl der in <paramref name="s"/> zu überprüfenden Zeichen.</param>
            <returns>Der NULL-basierte Index des ersten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf"/>
            in <paramref name="s"/> oder -1, wenn keines dieser Zeichen gefunden wurde. Wenn <paramref name="anyOf"/> eine
            leere Spanne ist, wird -1 zurückgegeben.</returns>
            <remarks>
            Wenn die Länge von <paramref name="anyOf"/> kleiner als 5 ist, verwendet die Methode für den Vergleich 
            MemoryExtensions.IndexOfAny&lt;T&gt;(ReadOnlySpan&lt;T&gt;, ReadOnlySpan&lt;T&gt;). Ist die Länge von <paramref name="anyOf"/>
            größer, wird <see cref="M:System.String.IndexOfAny(System.Char[])"/> verwendet.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> oder <paramref name="anyOf"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="startIndex"/> oder <paramref name="count"/> sind kleiner als 0
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="startIndex"/> + <paramref name="count"/> ist größer als die Anzahl der Zeichen in
            <paramref name="s"/>.
            </para>
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.IsAscii(System.String)">
            <summary>
            Untersucht, ob der <see cref="T:System.String"/> Unicode-Zeichen enthält,
            die nicht zum ASCII-Zeichensatz gehören.
            </summary>
            <param name="s">Der zu durchsuchende <see cref="T:System.String"/>.</param>
            <returns><c>false</c>, wenn <paramref name="s"/> ein Unicode-Zeichen enthält, das nicht zum 
            ASCII-Zeichensatz gehört, andernfalls <c>true</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.LastIndexOfAny(System.String,System.ReadOnlySpan{System.Char},System.Int32,System.Int32)">
            <summary>
            Gibt die nullbasierte Indexposition des letzten Vorkommens eines der angegebenen Zeichen 
            in <paramref name="s"/> an. Die Suche beginnt an einer angegebenen Zeichenposition 
            und verläuft für eine angegebene Anzahl von Zeichenpositionen rückwärts zum Anfang der Zeichenfolge.
            </summary>
            <param name="s">Der zu durchsuchende <see cref="T:System.String"/>.</param>
            <param name="anyOf">Eine schreibgeschützte Zeichenspanne, die die zu suchenden Zeichen enthält.</param>
            <param name="startIndex">Die Anfangsposition der Suche. Die Suche erfolgt rückwärts zum Anfang 
            von <paramref name="s"/>.</param>
            <param name="count">Die Anzahl der zu überprüfenden Zeichenpositionen.</param>
            <returns>Der nullbasierte Index des letzten Vorkommens eines beliebigen Zeichens aus <paramref name="anyOf"/>
            in <paramref name="s"/> oder -1, wenn keines dieser Zeichen gefunden wurde.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para>
            <paramref name="s"/> ist nicht <see cref="F:System.String.Empty"/> und <paramref name="startIndex"/> ist kleiner als 0 oder größer 
            oder gleich der Länge von <paramref name="s"/>
            </para>
            <para>
            - oder -
            </para>
            <para>
            <paramref name="s"/> ist nicht <see cref="F:System.String.Empty"/> und <paramref name="startIndex"/> - <paramref name="count"/> + 1 
            ist kleiner als 0.
            </para>
            </exception>
            <remarks>
            Wenn die Länge von <paramref name="anyOf"/> kleiner als 5 ist, verwendet die Methode für den Vergleich 
            <see cref="M:System.MemoryExtensions.LastIndexOfAny``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})"/>. Ist die Länge von <paramref name="anyOf"/>
            größer, wird <see cref="M:System.String.LastIndexOfAny(System.Char[])"/> verwendet.
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.NormalizeNewLinesTo(System.String,System.ReadOnlySpan{System.Char})">
            <summary>
            Erzeugt einen neuen <see cref="T:System.String"/>, in dem alle Zeilenumbrüche
            durch <paramref name="newLine"/> ersetzt sind.
            </summary>
            <param name="s">Der Quellstring.</param>
            <param name="newLine">Eine schreibgeschützte Zeichenspanne, durch deren Inhalt jeder Zeilenumbruch
            ersetzt wird. Wenn eine leere Spanne übergeben wird, werden alle Zeilenumbrüche entfernt.</param>
            <returns>Ein neuer <see cref="T:System.String"/>, in dem alle Zeilenumbrüche
            durch <paramref name="newLine"/> ersetzt sind. Wenn <paramref name="s"/> keine Zeilenwechselzeichen
            enthält, wird <paramref name="s"/> unverändert zurückgegeben.</returns>
            <remarks>
            <para>
            Für die Identifizierung von Zeilenwechselzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/> 
            verwendet. Die Sequenzen CRLF und LFCR werden als ein Zeilenumbruch behandelt.
            </para>
            <note type="caution">
            Diese Methode unterscheidet sich von <see cref="M:FolkerKinzel.Strings.StringExtension.ReplaceLineEndings(System.String,System.String)"/> dahingehend,
            dass sie zusätzlich LFCR-Sequenzen und Vertical Tab (VT: U+000B) als Zeilenwechsel behandelt.
            </note>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.ReplaceLineEndings(System.String)">
            <summary>
            Ersetzt alle Newlinesequenzen in <paramref name="s"/> durch <see cref="P:System.Environment.NewLine"/>.
            </summary>
            <param name="s">Der Quell-<see cref="T:System.String"/>.</param>
            <returns>Eine <see cref="T:System.String"/>, dessen Inhalt mit <paramref name="s"/> übereinstimmt - außer, dass alle Newlinesequenzen durch 
            <see cref="P:System.Environment.NewLine"/> ersetzt wurden.</returns>
            <remarks>
            <para>
            Die Methode ist ein Polyfill für die .NET 6.0-Methode String.ReplaceLineEndings(). Die Methode sollte deshalb nur in der 
            Erweiterungsmethodensyntax verwendet werden. Sie wirft eine <see cref="T:System.NullReferenceException"/>, wenn <paramref name="s"/>&#160;
            <c>null</c> ist, um ein identisches Verhalten mit der originalen .NET-Methode zu zeigen.
            </para>
            <para>
            Diese Methode sucht nach allen Newlinesequenzen innerhalb von <paramref name="s"/> und kanonisiert sie so, dass sie mit der 
            Newlinesequenz für die aktuelle Umgebung übereinstimmen. Wenn z.B. auf Windows ausgeführt wird, werden alle Vorkommen von Nicht-Windows 
            Newlinesequenzen durch die Sequenz CRLF ersetzt. Bei der Ausführung unter Unix werden alle Vorkommen von Nicht-Unix-Newlinesequenzen durch
            ein einzelnes LF-Zeichen ersetzt.
            </para>
            <para>
            Die Liste der behandelten Newlinesequenzen ist:
            </para>
            <list type="bullet">
            <item>CR (U+000D)</item>
            <item>LF (U+000A)</item>
            <item>CRLF (U+000D U+000A)</item>
            <item>NEL (U+0085)</item>
            <item>LS (U+2028)</item>
            <item>FF (U+000C)</item>
            <item>PS (U+2029)</item>
            </list>
            <para>
            Diese Liste ist vom Unicode-Standard vorgegeben (Sec. 5.8, Recommendation R4 und Table 5-2).
            </para>
            </remarks>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.ReplaceLineEndings(System.String,System.String)">
            <summary>
            Ersetzt alle Newlinesequenzen in <paramref name="s"/> durch <paramref name="replacementText"/>.
            </summary>
            <param name="s">Der Quell-<see cref="T:System.String"/>.</param>
            <param name="replacementText">Der Text, der als Ersatz verwendet werden soll. Wenn <paramref name="replacementText"/>&#160;
            <see cref="F:System.String.Empty"/> ist, werden alle Newlinesequenzen entfernt.</param>
            <returns>Ein <see cref="T:System.String"/>, dessen Inhalt mit <paramref name="s"/> übereinstimmt - außer, dass alle Newlinesequenzen durch 
            <paramref name="replacementText"/> ersetzt wurden.</returns>
            <remarks>
            <para>
            Die Methode ist ein Polyfill für die .NET 6.0-Methode String.ReplaceLineEndings(String). Die Methode sollte deshalb nur in der 
            Erweiterungsmethodensyntax verwendet werden. Sie wirft eine <see cref="T:System.NullReferenceException"/>, wenn <paramref name="s"/>&#160;
            <c>null</c> ist, um ein identisches Verhalten mit der originalen .NET-Methode zu zeigen.
            </para>
            <para>
            Die Liste der behandelten Newlinesequenzen ist:
            </para>
            <list type="bullet">
            <item>CR (U+000D)</item>
            <item>LF (U+000A)</item>
            <item>CRLF (U+000D U+000A)</item>
            <item>NEL (U+0085)</item>
            <item>LS (U+2028)</item>
            <item>FF (U+000C)</item>
            <item>PS (U+2029)</item>
            </list>
            <para>
            Diese Liste ist vom Unicode-Standard vorgegeben (Sec. 5.8, Recommendation R4 und Table 5-2).
            </para>
            </remarks>
            <exception cref="T:System.NullReferenceException"><paramref name="s"/> ist <c>null</c>.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="replacementText"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.ReplaceWhiteSpaceWith(System.String,System.ReadOnlySpan{System.Char},System.Boolean)">
            <summary>
            Erzeugt einen neuen <see cref="T:System.String"/>, in dem alle Sequenzen von Leerzeichen in <paramref name="s"/> durch 
            <paramref name="replacement"/> ersetzt sind.
            </summary>
            <param name="s">Der Quell-<see cref="T:System.String"/>.</param>
            <param name="replacement">Eine schreibgeschützte Zeichenspanne, durch deren Inhalt die Leerzeichen-Sequenzen
            ersetzt werden.</param>
            <param name="skipNewLines">Übergeben Sie <c>true</c>, um Zeilenumbruchzeichen von der 
            Ersetzung auszunehmen. Der Standardwert ist <c>false</c>.</param>
            <returns>Ein neuer <see cref="T:System.String"/>, in in dem alle Sequenzen von Leerzeichen in <paramref name="s"/> durch 
            <paramref name="replacement"/> ersetzt sind. Wenn <paramref name="s"/> kein Leerzeichen enthält, wird <paramref name="s"/>
            zurückgegeben.</returns>
            <remarks>
            <para>
            Die Methode verwendet <see cref="M:System.Char.IsWhiteSpace(System.Char)"/> zur Identifizierung von Leerraumzeichen und arbeitet
            damit gründlicher als 
            <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)">Regex.Replace(string input, @"\s+", string replacement)</see>.
            </para>
            <para>(Zur Identifizierung von Zeilenumbruchzeichen wird <see cref="M:FolkerKinzel.Strings.CharExtension.IsNewLine(System.Char)"/>
            verwendet.)
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.Trim(System.String,System.ReadOnlySpan{System.Char})">
            <summary>
            Erzeugt einen <see cref="T:System.String"/>, aus dem alle führenden und nachgestellten Vorkommen der Zeichen in der angegebenen Spanne entfernt sind.
            </summary>
            <param name="s">Die zu untersuchende Zeichenfolge.</param>
            <param name="trimChars">Eine Spanne mit den zu entfernenden Unicode-Zeichen. Wenn <paramref name="trimChars"/> eine leere Spanne ist,
            werden stattdessen Leerzeichen entfernt.</param>
            <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars"/>-Parameter übergebenen Zeichen am Anfang und Ende der 
            Zeichenfolge entfernt wurden. </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.TrimEnd(System.String,System.ReadOnlySpan{System.Char})">
            <summary>
            Erzeugt einen <see cref="T:System.String"/>, aus dem alle nachgestellten Vorkommen der Zeichen in der angegebenen Spanne entfernt sind.
            </summary>
            <param name="s">Die zu untersuchende Zeichenfolge.</param>
            <param name="trimChars">Eine Spanne mit den zu entfernenden Unicode-Zeichen. Wenn <paramref name="trimChars"/> eine leere Spanne ist,
            werden stattdessen Leerzeichen entfernt.</param>
            <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars"/>-Parameter übergebenen Zeichen am Ende der 
            Zeichenfolge entfernt wurden. </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="M:FolkerKinzel.Strings.StringExtension.TrimStart(System.String,System.ReadOnlySpan{System.Char})">
            <summary>
            Erzeugt einen <see cref="T:System.String"/>, aus dem alle führenden Vorkommen der Zeichen in der angegebenen Spanne entfernt sind.
            </summary>
            <param name="s">Die zu untersuchende Zeichenfolge.</param>
            <param name="trimChars">Eine Spanne mit den zu entfernenden Unicode-Zeichen. Wenn <paramref name="trimChars"/> eine leere Spanne ist,
            werden stattdessen Leerzeichen entfernt.</param>
            <returns>Die resultierende Zeichenfolge, nachdem alle im <paramref name="trimChars"/>-Parameter übergebenen Zeichen am Anfang der 
            Zeichenfolge entfernt wurden. </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="s"/> ist <c>null</c>.</exception>
        </member>
        <member name="T:FolkerKinzel.Strings.TextEncodingConverter">
            <summary>
            Kapselt Methoden, die das Erzeugen geeigneter Instanzen der <see cref="T:System.Text.Encoding"/>-Klasse unterstützen.
            </summary>
        </member>
        <member name="M:FolkerKinzel.Strings.TextEncodingConverter.GetEncoding(System.String,System.Boolean)">
            <summary>
            Gibt für den angegebenen Bezeichner eines Zeichensatzes ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt
            zurück.
            </summary>
            
            <param name="encodingWebName">Der Bezeichner des Zeichensatzes.</param>
            <param name="throwOnInvalidWebName">Geben Sie <c>true</c> an, damit die Methode
            eine <see cref="T:System.ArgumentException"/> wirft, falls <paramref name="encodingWebName"/> nicht übersetzt werden konnte.</param>
            
            <returns>Ein <see cref="T:System.Text.Encoding"/>-Objekt, das dem angegebenen Bezeichner des Zeichensatzes
            entspricht. Falls keine Entsprechung gefunden wurde, wird in der Standardeinstellung <see cref="P:System.Text.Encoding.UTF8"/> zurückgegeben.
            Wenn die Methode mit <c>true</c> als Argument für den Parameter <paramref name="throwOnInvalidWebName"/> aufgerufen wird, wird
            in diesem Fall eine <see cref="T:System.ArgumentException"/> geworfen.</returns>
            
            <remarks>
            <para>
            .NET Standard und .NET 5.0 oder höher erkennen in der Standardeinstellung nur eine geringe Anzahl von Zeichensätzen.
            Die Methode überschreibt diese Standardeinstellung.
            </para>
            <para>
            Die Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/> des erzeugten
            <see cref="T:System.Text.Encoding"/>-Objekts sind auf ReplacementFallback eingestellt.
            </para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">
            <paramref name="encodingWebName"/> konnte keinem <see cref="T:System.Text.Encoding"/>-Objekt zugeordnet werden. Eine Ausnahme wird nur dann geworfen, wenn
            für den optionalen Parameter <paramref name="throwOnInvalidWebName"/>&#160;<c>true</c> übergeben wurde.
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.TextEncodingConverter.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback,System.Boolean)">
            <summary>
            Gibt für den angegebenen Bezeichner eines Zeichensatzes ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt
            zurück, dessen Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/>
            auf die gewünschten Werte eingestellt sind.
            </summary>
            
            <param name="encodingWebName">Der Bezeichner des Zeichensatzes.</param>
            <param name="encoderFallback">Ein Objekt, das einen Fehlerbehandlungsmechanismus zur Verfügung stellt,
            falls ein Zeichen mit dem <see cref="T:System.Text.Encoding"/>-Objekt nicht enkodiert werden kann.</param>
            <param name="decoderFallback">
            Ein Objekt, das einen Fehlerbehandlungsmechanismus zur Verfügung stellt,
            falls eine <see cref="T:System.Byte"/>-Sequenz mit dem <see cref="T:System.Text.Encoding"/>-Objekt nicht dekodiert werden kann.</param>
            <param name="throwOnInvalidWebName">Geben Sie <c>true</c> an, damit die Methode
            eine <see cref="T:System.ArgumentException"/> wirft, falls <paramref name="encodingWebName"/> nicht übersetzt werden konnte.</param>
            
            <returns>Ein <see cref="T:System.Text.Encoding"/>-Objekt, das dem angegebenen Bezeichner des Zeichensatzes
            entspricht und dessen Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/>
            auf die gewünschten Werte eingestellt sind. Falls keine Entsprechung gefunden wurde, wird in der Standardeinstellung 
            ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt für UTF-8 zurückgegeben.
            Wenn die Methode mit <c>true</c> als Argument für den Parameter <paramref name="throwOnInvalidWebName"/> aufgerufen wird, wird
            in diesem Fall eine <see cref="T:System.ArgumentException"/> geworfen.</returns>
            
            <remarks>
            .NET Standard und .NET 5.0 oder höher erkennen in der Standardeinstellung nur eine geringe Anzahl von Zeichensätzen.
            Die Methode überschreibt diese Standardeinstellung.
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="encoderFallback"/> oder <paramref name="decoderFallback"/> ist <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="encodingWebName"/> konnte keinem <see cref="T:System.Text.Encoding"/>-Objekt zugeordnet werden. Diese Ausnahme wird nur dann geworfen, wenn
            für den optionalen Parameter <paramref name="throwOnInvalidWebName"/>&#160;<c>true</c> übergeben wurde.
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.TextEncodingConverter.GetEncoding(System.Int32,System.Boolean)">
            <summary>
            Gibt für die angegebene Nummer einer Codepage ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt
            zurück.
            </summary>
            <param name="codePage">
            <para>
            Die Nummer der Codepage.
            </para>
            <note type="caution">
            <c>0</c> wird als ungültiges Argument behandelt. Das Verhalten unterscheidet sich damit von dem der
            <see cref="T:System.Text.Encoding"/>-Klasse.
            </note>
            </param>
            <param name="throwOnInvalidCodePage">Geben Sie <c>true</c> an, damit die Methode
            eine <see cref="T:System.ArgumentException"/> wirft, falls <paramref name="codePage"/> nicht übersetzt werden konnte.</param>
            
            <returns>
            Ein <see cref="T:System.Text.Encoding"/>-Objekt, das der angegebenen Nummer der Codepage
            entspricht. Falls keine Entsprechung gefunden wurde, wird in der Standardeinstellung <see cref="P:System.Text.Encoding.UTF8"/> zurückgegeben.
            Wenn die Methode mit <c>true</c> als Argument für den Parameter <paramref name="throwOnInvalidCodePage"/> aufgerufen wird, wird
            in diesem Fall eine <see cref="T:System.ArgumentException"/> geworfen.
            </returns>
            
            <remarks>
            <para>
            .NET Standard und .NET 5.0 oder höher erkennen in der Standardeinstellung nur eine geringe Anzahl von Zeichensätzen.
            Die Methode überschreibt diese Standardeinstellung.
            </para>
            <para>
            Die Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/> des erzeugten
            <see cref="T:System.Text.Encoding"/>-Objekts sind auf ReplacementFallback eingestellt.
            </para>
            </remarks>
            
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="codePage"/> ist kleiner als 1 oder größer als 65535. Diese Ausnahme wird nur dann geworfen, wenn
            für den optionalen Parameter <paramref name="throwOnInvalidCodePage"/>&#160;<c>true</c> übergeben wurde.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="codePage"/> konnte keinem <see cref="T:System.Text.Encoding"/>-Objekt zugeordnet werden. Diese Ausnahme wird nur dann geworfen, wenn
            für den optionalen Parameter <paramref name="throwOnInvalidCodePage"/>&#160;<c>true</c> übergeben wurde.
            </exception>
            
        </member>
        <member name="M:FolkerKinzel.Strings.TextEncodingConverter.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback,System.Boolean)">
            <summary>
            Gibt für die angegebene Nummer einer Codepage ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt
            zurück, dessen Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/>
            auf die gewünschten Werte eingestellt sind.
            </summary>
            
            <param name="codePage">
            <para>
            Die Nummer der Codepage.
            </para>
            <note type="caution">
            <c>0</c> wird als ungültiges Argument behandelt. Das Verhalten unterscheidet sich damit von
            dem der <see cref="T:System.Text.Encoding"/>-Klasse.
            </note></param>
            
            <param name="encoderFallback">Ein Objekt, das einen Fehlerbehandlungsmechanismus zur Verfügung stellt,
            falls ein Zeichen mit dem <see cref="T:System.Text.Encoding"/>-Objekt nicht enkodiert werden kann.</param>
            <param name="decoderFallback">
            Ein Objekt, das einen Fehlerbehandlungsmechanismus zur Verfügung stellt,
            falls eine <see cref="T:System.Byte"/>-Sequenz mit dem <see cref="T:System.Text.Encoding"/>-Objekt nicht dekodiert werden kann.</param>
            <param name="throwOnInvalidCodePage">Geben Sie <c>true</c> an, damit die Methode
            eine <see cref="T:System.ArgumentException"/> wirft, falls <paramref name="codePage"/> nicht übersetzt werden konnte.</param>
             
            <returns>Ein <see cref="T:System.Text.Encoding"/>-Objekt, das der angegebenen Nummer der Codepage
            entspricht und dessen Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/>
            auf die gewünschten Werte eingestellt sind. Falls keine Entsprechung gefunden wurde, wird in der Standardeinstellung 
            ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt für UTF-8 zurückgegeben.
            Wenn die Methode mit <c>true</c> als Argument für den Parameter <paramref name="throwOnInvalidCodePage"/> aufgerufen wird, wird
            in diesem Fall eine <see cref="T:System.ArgumentException"/> geworfen.</returns>
            
            <remarks>
            .NET Standard und .NET 5.0 oder höher erkennen in der Standardeinstellung nur eine geringe Anzahl von Zeichensätzen.
            Die Methode überschreibt diese Standardeinstellung.
            </remarks>
            
            <exception cref="T:System.ArgumentNullException">
            <paramref name="encoderFallback"/> oder <paramref name="decoderFallback"/> ist <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="codePage"/> ist kleiner als 1 oder größer als 65535. Diese Ausnahme wird nur dann geworfen, wenn
            für den optionalen Parameter <paramref name="throwOnInvalidCodePage"/>&#160;<c>true</c> übergeben wurde.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="codePage"/> konnte keinem <see cref="T:System.Text.Encoding"/>-Objekt zugeordnet werden. Diese Ausnahme wird nur dann geworfen, wenn
            für den optionalen Parameter <paramref name="throwOnInvalidCodePage"/>&#160;<c>true</c> übergeben wurde.
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.TextEncodingConverter.TryGetEncoding(System.String,System.Text.Encoding@)">
            <summary>
            Versucht, für den angegebenen Bezeichner eines Zeichensatzes ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt
            zurückzugeben.
            </summary>
            
            <param name="encodingWebName">Der Bezeichner des Zeichensatzes.</param>
            <param name="encoding">Enthält nach dem erfolgreichen Beenden der Methode ein <see cref="T:System.Text.Encoding"/>-Objekt, 
            das dem angegebenen Bezeichner des Zeichensatzes entspricht, andernfalls <c>null</c>. Der Parameter wird 
            uninitialisiert übergeben.</param>
            
            <returns><c>true</c>, wenn die Konvertierung erfolgreich war, andernfalls <c>false</c>.</returns>
            
            <remarks>
            <para>
            .NET Standard und .NET 5.0 oder höher erkennen in der Standardeinstellung nur eine geringe Anzahl von Zeichensätzen.
            Die Methode überschreibt diese Standardeinstellung.
            </para>
            <para>
            Die Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/> des erzeugten
            <see cref="T:System.Text.Encoding"/>-Objekts sind auf ReplacementFallback eingestellt.
            </para>
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.TextEncodingConverter.TryGetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback,System.Text.Encoding@)">
            <summary>
            Versucht, für den angegebenen Bezeichner eines Zeichensatzes ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt
            zurückzugeben, dessen Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/>
            auf die gewünschten Werte eingestellt sind.
            </summary>
            
            <param name="encodingWebName">Der Bezeichner des Zeichensatzes.</param>
            <param name="encoderFallback">Ein Objekt, das einen Fehlerbehandlungsmechanismus zur Verfügung stellt,
            falls ein Zeichen mit dem <see cref="T:System.Text.Encoding"/>-Objekt nicht enkodiert werden kann.</param>
            <param name="decoderFallback">
            Ein Objekt, das einen Fehlerbehandlungsmechanismus zur Verfügung stellt,
            falls eine <see cref="T:System.Byte"/>-Sequenz mit dem <see cref="T:System.Text.Encoding"/>-Objekt nicht dekodiert werden kann.</param>
            <param name="encoding">Enthält nach dem erfolgreichen Beenden der Methode ein <see cref="T:System.Text.Encoding"/>-Objekt, 
            das dem angegebenen Bezeichner des Zeichensatzes entspricht und dessen Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> 
            und <see cref="P:System.Text.Encoding.DecoderFallback"/> auf die gewünschten Werte eingestellt sind, andernfalls <c>null</c>. Der Parameter wird 
            uninitialisiert übergeben.</param>
            
            <returns><c>true</c>, wenn die Konvertierung erfolgreich war, andernfalls <c>false</c>.</returns>
            
            <remarks>
            .NET Standard und .NET 5.0 oder höher erkennen in der Standardeinstellung nur eine geringe Anzahl von Zeichensätzen.
            Die Methode überschreibt diese Standardeinstellung.
            </remarks>
            
            <exception cref="T:System.ArgumentNullException">
            <paramref name="encoderFallback"/> oder <paramref name="decoderFallback"/> ist <c>null</c>.
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.TextEncodingConverter.TryGetEncoding(System.Int32,System.Text.Encoding@)">
            <summary>
            Versucht, für die angegebene Nummer einer Codepage ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt
            zurückzugeben.
            </summary>
            
            <param name="codePage">
            <para>
            Die Nummer der Codepage.
            </para>
            <note type="caution">
            <c>0</c> wird als ungültiges Argument behandelt. Das Verhalten unterscheidet sich damit von
            dem der <see cref="T:System.Text.Encoding"/>-Klasse.
            </note></param>
            <param name="encoding">Enthält nach dem erfolgreichen Beenden der Methode ein <see cref="T:System.Text.Encoding"/>-Objekt, 
            das der angegebenen Nummer der Codepage entspricht, andernfalls <c>null</c>. Der Parameter wird 
            uninitialisiert übergeben.</param>
            
            <returns><c>true</c>, wenn die Konvertierung erfolgreich war, andernfalls <c>false</c>.</returns>
            
            <remarks>
            <para>
            .NET Standard und .NET 5.0 oder höher erkennen in der Standardeinstellung nur eine geringe Anzahl von Zeichensätzen.
            Die Methode überschreibt diese Standardeinstellung.
            </para>
            <para>
            Die Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/> des erzeugten
            <see cref="T:System.Text.Encoding"/>-Objekts sind auf ReplacementFallback eingestellt.
            </para>
            </remarks>
        </member>
        <member name="M:FolkerKinzel.Strings.TextEncodingConverter.TryGetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback,System.Text.Encoding@)">
            <summary>
            Versucht, für die angegebene Nummer einer Codepage ein entsprechendes <see cref="T:System.Text.Encoding"/>-Objekt
            zurückzugeben, dessen Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> und <see cref="P:System.Text.Encoding.DecoderFallback"/>
            auf die gewünschten Werte eingestellt sind.
            </summary>
            
            <param name="codePage">
            <para>
            Die Nummer der Codepage.
            </para>
            <note type="caution">
            <c>0</c> wird als ungültiges Argument behandelt. Das Verhalten unterscheidet sich damit von
            dem der <see cref="T:System.Text.Encoding"/>-Klasse.
            </note></param>
            
            <param name="encoderFallback">Ein Objekt, das einen Fehlerbehandlungsmechanismus zur Verfügung stellt,
            falls ein Zeichen mit dem <see cref="T:System.Text.Encoding"/>-Objekt nicht enkodiert werden kann.</param>
            <param name="decoderFallback">
            Ein Objekt, das einen Fehlerbehandlungsmechanismus zur Verfügung stellt,
            falls eine <see cref="T:System.Byte"/>-Sequenz mit dem <see cref="T:System.Text.Encoding"/>-Objekt nicht dekodiert werden kann.</param>
            <param name="encoding">Enthält nach dem erfolgreichen Beenden der Methode ein <see cref="T:System.Text.Encoding"/>-Objekt, 
            das der angegebenen Nummer der Codepage entspricht und dessen Eigenschaften <see cref="P:System.Text.Encoding.EncoderFallback"/> 
            und <see cref="P:System.Text.Encoding.DecoderFallback"/> auf die gewünschten Werte eingestellt sind, andernfalls <c>null</c>. Der Parameter wird 
            uninitialisiert übergeben.</param>
            
            <returns><c>true</c>, wenn die Konvertierung erfolgreich war, andernfalls <c>false</c>.</returns>
            
            <remarks>
            .NET Standard und .NET 5.0 oder höher erkennen in der Standardeinstellung nur eine geringe Anzahl von Zeichensätzen.
            Die Methode überschreibt diese Standardeinstellung.
            </remarks>
            
            <exception cref="T:System.ArgumentNullException">
            <paramref name="encoderFallback"/> oder <paramref name="decoderFallback"/> ist <c>null</c>.
            </exception>
        </member>
        <member name="M:FolkerKinzel.Strings.TextEncodingConverter.GetCodePage(System.ReadOnlySpan{System.Byte},System.Int32@)">
            <summary>
            Untersucht eine schreibgeschützte <see cref="T:System.Byte"/>-Spanne, die den Inhalt
            einer Textdatei darstellt, daraufhin, ob
            sie mit einem Byte Order Mark (BOM) beginnt und gibt eine geeignete Codepage
            zurück. (Das Fallback-Value ist 65001 für UTF-8.)
            </summary>
            <param name="data">Die zu untersuchende Spanne.</param>
            <param name="bomLength">Enthält nach Beendigung der Methode die Länge des gefundenen BOM oder 0, wenn kein BOM
            gefunden wurde. Der Parameter wird uninitialisiert übergeben.</param>
            <returns>Eine geeignete Codepage für <paramref name="data"/> oder die Codepage
            für UTF-8 (65001), falls die Codepage nicht aus <paramref name="data"/> ermittelt
            werden konnte.</returns>
            <remarks>
            Die Methode erkennt die Byte Order Marks für die folgenden Zeichensätze:
            <list type="bullet">
            <item>UTF-8</item>
            <item>UTF-16LE</item>
            <item>UTF-16BE</item>
            <item>UTF-32LE</item>
            <item>UTF-32BE</item>
            <item>UTF-7</item>
            <item>GB18030</item>
            </list>
            <para>
            UTF-16LE, UTF-16BE, UTF-32LE und UTF-32BE können von der Methode u.U. auch dann aus den
            Daten erkannt werden, wenn kein Byte Order Mark vorliegt.
            </para>
            </remarks>
        </member>
    </members>
</doc>
